/**
 * WASM Backend Implementation
 *
 * Hybrid backend that uses local WASM for instant game logic (movement, interaction)
 * and HTTP for C compilation, saves, and persistence.
 *
 * Design decisions:
 * - Level data embedded in WASM (no fetch needed)
 * - Periodic sync every 30s + on key events
 * - No HTTP fallback (WASM-only for web)
 */

import type {
    Backend,
    UnsubscribeFn,
    GameState,
    RenderState,
    PlayerAction,
    LevelData,
    LevelInfo,
    CodeResult,
    CodeOutput,
    LevelCompleteEvent,
    GameError,
    SaveSlot,
    PlayerProgress,
    QuestInfo,
} from './types';

// WASM module type (generated by wasm-pack)
interface WasmGameModule {
    WasmGame: new () => WasmGameInstance;
    default: () => Promise<unknown>;
}

interface WasmGameInstance {
    init_from_state(state: unknown): void;
    process_action(action: unknown): unknown;
    get_render_state(): unknown;
    get_game_state(): unknown;
    load_level(levelId: string): unknown;
    get_available_levels(): unknown;
    get_level_data(): unknown;
    complete_level(xpReward: number): unknown;
    sync_progression(totalXp: number, completedLevels: string[]): void;
    get_hint(hintIndex: number): string;
}

declare const __API_URL__: string | undefined;
const API_URL = typeof __API_URL__ !== 'undefined' ? __API_URL__ : 'http://localhost:3000';

const DEVICE_ID_KEY = 'code-warrior-device-id';
const SYNC_INTERVAL_MS = 30000; // 30 seconds
const SYNC_DEBOUNCE_MS = 5000;  // 5 second debounce

function getOrCreateDeviceId(): string {
    if (typeof localStorage === 'undefined') return 'ssr-device';
    let deviceId = localStorage.getItem(DEVICE_ID_KEY);
    if (!deviceId) {
        deviceId = `device-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
        localStorage.setItem(DEVICE_ID_KEY, deviceId);
    }
    return deviceId;
}

async function apiRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const deviceId = getOrCreateDeviceId();
    const response = await fetch(`${API_URL}${endpoint}`, {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            'X-Device-ID': deviceId,
            ...options.headers,
        },
    });
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    return response.json();
}

class WasmBackend implements Backend {
    private wasmGame: WasmGameInstance | null = null;
    private wasmModule: WasmGameModule | null = null;
    private initPromise: Promise<void> | null = null;
    private syncInterval: ReturnType<typeof setInterval> | null = null;
    private lastSyncTime: number = 0;

    constructor() {
        this.initPromise = this.initWasm();
    }

    private async initWasm(): Promise<void> {
        try {
            // Dynamic import of WASM module from src/lib/wasm
            const wasmModule = await import('../wasm/code_warrior_wasm.js') as WasmGameModule;
            // Initialize the WASM module (wasm-bindgen handles the .wasm file location)
            if (wasmModule.default) {
                await wasmModule.default();
            }
            this.wasmModule = wasmModule;
            this.wasmGame = new wasmModule.WasmGame();
            console.log('[WASM] Game engine initialized');
            this.startPeriodicSync();
        } catch (error) {
            console.error('[WASM] Failed to initialize:', error);
            throw error;
        }
    }

    private async ensureWasm(): Promise<WasmGameInstance> {
        if (this.initPromise) {
            await this.initPromise;
            this.initPromise = null;
        }
        if (!this.wasmGame) {
            throw new Error('WASM game not initialized');
        }
        return this.wasmGame;
    }

    private startPeriodicSync(): void {
        if (this.syncInterval) return;
        this.syncInterval = setInterval(() => {
            this.syncToServer().catch(err =>
                console.warn('[WASM] Periodic sync failed:', err)
            );
        }, SYNC_INTERVAL_MS);
    }

    private async syncToServer(): Promise<void> {
        const now = Date.now();
        if (now - this.lastSyncTime < SYNC_DEBOUNCE_MS) return;

        const wasm = await this.ensureWasm();
        const state = wasm.get_game_state();

        await apiRequest('/api/game/sync', {
            method: 'POST',
            body: JSON.stringify({ game_state: state })
        }).catch(err => console.warn('[WASM] Sync failed:', err));

        this.lastSyncTime = now;
    }

    // === Game Lifecycle ===

    async initGame(): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        // Try to get existing state from server
        try {
            const response = await apiRequest<{ game_state: GameState }>('/api/game/init', {
                method: 'POST',
                body: JSON.stringify({})
            });
            if (response.game_state) {
                wasm.init_from_state(response.game_state);
            }
        } catch (err) {
            console.warn('[WASM] Failed to get server state, using fresh state:', err);
        }

        return wasm.get_render_state() as RenderState;
    }

    async getGameState(): Promise<GameState> {
        const wasm = await this.ensureWasm();
        return wasm.get_game_state() as GameState;
    }

    async getRenderState(): Promise<RenderState> {
        const wasm = await this.ensureWasm();
        return wasm.get_render_state() as RenderState;
    }

    async processAction(action: PlayerAction): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        if (action.type === 'submit_code') {
            throw new Error('Use submitCode() method for code submission');
        }

        return wasm.process_action(action) as RenderState;
    }

    // === Levels ===

    async getAvailableLevels(): Promise<LevelInfo[]> {
        const wasm = await this.ensureWasm();
        return wasm.get_available_levels() as LevelInfo[];
    }

    async loadLevel(levelId: string): Promise<void> {
        const wasm = await this.ensureWasm();
        wasm.load_level(levelId);

        // Notify server asynchronously (don't block)
        apiRequest(`/api/levels/${levelId}/load`, { method: 'POST' })
            .catch(err => console.warn('[WASM] Failed to notify server of level load:', err));
    }

    async getLevelData(): Promise<LevelData> {
        const wasm = await this.ensureWasm();
        return wasm.get_level_data() as LevelData;
    }

    // === Quests (HTTP for quest info, code compilation on server) ===

    async getLevelQuests(): Promise<QuestInfo[]> {
        return apiRequest<QuestInfo[]>('/api/levels/current/quests');
    }

    async loadQuest(questId: string): Promise<QuestInfo> {
        return apiRequest<QuestInfo>(`/api/levels/current/quests/${questId}`);
    }

    async submitQuestCode(code: string, questId: string, testOnly: boolean = false): Promise<CodeResult> {
        const wasm = await this.ensureWasm();

        const result = await apiRequest<CodeResult & { xp_earned?: number }>(
            '/api/code/submit-quest',
            { method: 'POST', body: JSON.stringify({ code, quest_id: questId, test_only: testOnly }) }
        );

        // If code succeeded and not test-only, update local state
        if (result.success && !testOnly && result.xp_earned) {
            wasm.complete_level(result.xp_earned);
            this.syncToServer().catch(err =>
                console.warn('[WASM] Post-quest-complete sync failed:', err)
            );
        }

        return result;
    }

    // === Code (HTTP only - can't compile C in browser) ===

    async submitCode(code: string, testOnly: boolean = false): Promise<CodeResult> {
        const wasm = await this.ensureWasm();

        const result = await apiRequest<CodeResult & { xp_earned?: number }>(
            '/api/code/submit',
            { method: 'POST', body: JSON.stringify({ code, test_only: testOnly }) }
        );

        // If code succeeded and not test-only, update local state
        if (result.success && !testOnly && result.xp_earned) {
            wasm.complete_level(result.xp_earned);
            // Sync immediately after level complete
            this.syncToServer().catch(err =>
                console.warn('[WASM] Post-complete sync failed:', err)
            );
        }

        return result;
    }

    async getHint(hintIndex: number): Promise<string> {
        const wasm = await this.ensureWasm();
        return wasm.get_hint(hintIndex);
    }

    // === Save/Load (HTTP only - persistence on server) ===

    async listSaves(): Promise<SaveSlot[]> {
        return apiRequest<SaveSlot[]>('/api/saves');
    }

    async saveGame(slotId: string): Promise<void> {
        // Sync current state first
        await this.syncToServer();
        await apiRequest(`/api/saves/${slotId}`, { method: 'POST' });
    }

    async loadGame(slotId: string): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        const response = await apiRequest<{ game_state: GameState }>(
            `/api/saves/${slotId}`
        );

        if (response.game_state) {
            wasm.init_from_state(response.game_state);
        }

        return wasm.get_render_state() as RenderState;
    }

    async deleteSave(slotId: string): Promise<void> {
        await apiRequest(`/api/saves/${slotId}`, { method: 'DELETE' });
    }

    // === Progress ===

    async getProgress(): Promise<PlayerProgress> {
        const wasm = await this.ensureWasm();
        const state = wasm.get_game_state() as GameState;

        return {
            total_xp: state.total_xp ?? 0,
            completed_levels: state.levels_completed ?? [],
            current_level: state.current_level_id ?? null,
        };
    }

    // === Events (no-op for WASM - state is local) ===

    async onGameTick(_cb: (state: RenderState) => void): Promise<UnsubscribeFn> {
        // No polling needed - state is local
        return () => {};
    }

    async onCodeOutput(_cb: (output: CodeOutput) => void): Promise<UnsubscribeFn> {
        return () => {};
    }

    async onLevelComplete(_cb: (event: LevelCompleteEvent) => void): Promise<UnsubscribeFn> {
        return () => {};
    }

    async onGameError(_cb: (error: GameError) => void): Promise<UnsubscribeFn> {
        return () => {};
    }

    // === Cleanup ===

    cleanup(): void {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
        // Final sync on cleanup
        this.syncToServer().catch(() => {});
    }
}

export function createWasmBackend(): Backend {
    return new WasmBackend();
}
