/**
 * WASM Backend Implementation
 *
 * Hybrid backend that uses local WASM for instant game logic (movement, interaction)
 * and HTTP for C compilation, quest completion, and persistence.
 *
 * Architecture:
 * - Server is source of truth for ALL progression (levels, quests, XP)
 * - WASM handles local game state (player position, game phase)
 * - State flows: Server → WASM on init/load, HTTP → Server on code submit
 */

import type {
    Backend,
    UnsubscribeFn,
    GameState,
    RenderState,
    PlayerAction,
    LevelData,
    LevelInfo,
    CodeResult,
    SaveSlot,
    PlayerProgress,
    QuestInfo,
} from './types';

// WASM module type (generated by wasm-pack)
interface WasmGameModule {
    WasmGame: new () => WasmGameInstance;
    default: () => Promise<unknown>;
}

interface WasmGameInstance {
    init_from_state(state: unknown): void;
    process_action(action: unknown): unknown;
    get_render_state(): unknown;
    get_game_state(): unknown;
    load_level(levelId: string): unknown;
    get_available_levels(): unknown;
    get_level_data(): unknown;
    complete_level(xpReward: number): unknown;
    sync_progression(totalXp: number, completedLevels: string[]): void;
    get_hint(hintIndex: number): string;
}

declare const __API_URL__: string | undefined;
const API_URL = typeof __API_URL__ !== 'undefined' ? __API_URL__ : 'http://localhost:3000';

const DEVICE_ID_KEY = 'code-warrior-device-id';

function getOrCreateDeviceId(): string {
    if (typeof localStorage === 'undefined') return 'ssr-device';
    let deviceId = localStorage.getItem(DEVICE_ID_KEY);
    if (!deviceId) {
        deviceId = `device-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
        localStorage.setItem(DEVICE_ID_KEY, deviceId);
    }
    return deviceId;
}

async function apiRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const deviceId = getOrCreateDeviceId();
    const response = await fetch(`${API_URL}${endpoint}`, {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            'X-Device-ID': deviceId,
            ...options.headers,
        },
    });
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    return response.json();
}

class WasmBackend implements Backend {
    private wasmGame: WasmGameInstance | null = null;
    private wasmModule: WasmGameModule | null = null;
    private initPromise: Promise<void> | null = null;

    constructor() {
        this.initPromise = this.initWasm();
    }

    private async initWasm(): Promise<void> {
        try {
            const wasmModule = await import('../wasm/code_warrior_wasm.js') as WasmGameModule;
            if (wasmModule.default) {
                await wasmModule.default();
            }
            this.wasmModule = wasmModule;
            this.wasmGame = new wasmModule.WasmGame();
            console.log('[WASM] Game engine initialized');
        } catch (error) {
            console.error('[WASM] Failed to initialize:', error);
            throw error;
        }
    }

    private async ensureWasm(): Promise<WasmGameInstance> {
        if (this.initPromise) {
            await this.initPromise;
            this.initPromise = null;
        }
        if (!this.wasmGame) {
            throw new Error('WASM game not initialized');
        }
        return this.wasmGame;
    }

    // === Game Lifecycle ===

    async initGame(): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        // Load existing state from server into WASM
        try {
            const response = await apiRequest<{ game_state: GameState }>('/api/game/init', {
                method: 'POST',
                body: JSON.stringify({})
            });
            if (response.game_state) {
                wasm.init_from_state(response.game_state);
            }
        } catch (err) {
            console.warn('[WASM] Failed to get server state, using fresh state:', err);
        }

        return wasm.get_render_state() as RenderState;
    }

    async getGameState(): Promise<GameState> {
        const wasm = await this.ensureWasm();
        return wasm.get_game_state() as GameState;
    }

    async getRenderState(): Promise<RenderState> {
        const wasm = await this.ensureWasm();
        return wasm.get_render_state() as RenderState;
    }

    async processAction(action: PlayerAction): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        if (action.type === 'submit_code') {
            throw new Error('Use submitCode() method for code submission');
        }

        return wasm.process_action(action) as RenderState;
    }

    // === Levels ===

    async getAvailableLevels(): Promise<LevelInfo[]> {
        const wasm = await this.ensureWasm();
        return wasm.get_available_levels() as LevelInfo[];
    }

    async loadLevel(levelId: string): Promise<void> {
        const wasm = await this.ensureWasm();
        wasm.load_level(levelId);

        // Notify server asynchronously (don't block)
        apiRequest(`/api/levels/${levelId}/load`, { method: 'POST' })
            .catch(err => console.warn('[WASM] Failed to notify server of level load:', err));
    }

    async getLevelData(): Promise<LevelData> {
        const wasm = await this.ensureWasm();
        return wasm.get_level_data() as LevelData;
    }

    // === Quests (HTTP handles quest completion tracking) ===

    async getLevelQuests(): Promise<QuestInfo[]> {
        return apiRequest<QuestInfo[]>('/api/levels/current/quests');
    }

    async loadQuest(questId: string): Promise<QuestInfo> {
        return apiRequest<QuestInfo>(`/api/levels/current/quests/${questId}`);
    }

    async submitQuestCode(code: string, questId: string, testOnly: boolean = false): Promise<CodeResult> {
        // Server handles quest completion and XP tracking
        // Frontend uses result.render_state from HTTP response
        return apiRequest<CodeResult>('/api/code/submit-quest', {
            method: 'POST',
            body: JSON.stringify({ code, quest_id: questId, test_only: testOnly })
        });
    }

    // === Code (HTTP handles compilation and level completion) ===

    async submitCode(code: string, testOnly: boolean = false): Promise<CodeResult> {
        const wasm = await this.ensureWasm();

        const result = await apiRequest<CodeResult & { xp_earned?: number }>(
            '/api/code/submit',
            { method: 'POST', body: JSON.stringify({ code, test_only: testOnly }) }
        );

        // Update local WASM state for single-challenge levels
        // Server already persisted the completion via HTTP
        if (result.success && !testOnly && result.xp_earned) {
            wasm.complete_level(result.xp_earned);
        }

        return result;
    }

    async getHint(hintIndex: number): Promise<string> {
        const wasm = await this.ensureWasm();
        return wasm.get_hint(hintIndex);
    }

    // === Save/Load (Server is source of truth) ===

    async listSaves(): Promise<SaveSlot[]> {
        return apiRequest<SaveSlot[]>('/api/saves');
    }

    async saveGame(slotId: string): Promise<void> {
        // Server saves current session state (already correct from HTTP calls)
        await apiRequest(`/api/saves/${slotId}`, { method: 'POST' });
    }

    async loadGame(slotId: string): Promise<RenderState> {
        const wasm = await this.ensureWasm();

        const response = await apiRequest<{ render_state: RenderState }>(`/api/saves/${slotId}`);

        // Load server state into WASM
        if (response.render_state) {
            // Re-init from server to get full state
            const fullState = await apiRequest<{ game_state: GameState }>('/api/game/state');
            if (fullState.game_state) {
                wasm.init_from_state(fullState.game_state);
            }
        }

        return wasm.get_render_state() as RenderState;
    }

    async deleteSave(slotId: string): Promise<void> {
        await apiRequest(`/api/saves/${slotId}`, { method: 'DELETE' });
    }

    // === Progress (from server) ===

    async getProgress(): Promise<PlayerProgress> {
        // Get progress from server (source of truth)
        return apiRequest<PlayerProgress>('/api/player/progress');
    }

    // === Events ===

    async onGameTick(_cb: (state: RenderState) => void): Promise<UnsubscribeFn> {
        // WASM is synchronous - state is fetched on demand, no polling needed
        return () => {};
    }

    // === Cleanup ===

    cleanup(): void {
        // No cleanup needed - server maintains state
    }
}

export function createWasmBackend(): Backend {
    return new WasmBackend();
}
