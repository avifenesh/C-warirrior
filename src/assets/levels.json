[
  {
    "id": "L01",
    "title": "The First Spell",
    "concept": "printf",
    "description": "The door is voice-activated. You must speak the ancient password to enter.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    // Print 'Hello, World!'\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Hello, World!\n"
    },
    "hints": [
      "Use printf() to print text to the screen",
      "Don't forget the \\n at the end for a newline",
      "The syntax is: printf(\"text here\\n\");"
    ],
    "xp_reward": 50,
    "map_file": "maps/L01_first_spell.json",
    "challenges": [
      {
        "id": "printf_hello",
        "prompt": "Cast your first spell by printing 'Hello, World!'",
        "expected_output": "Hello, World!",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    // Your spell here\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L02",
    "title": "The Empty Backpack",
    "concept": "variables",
    "description": "You found a sword, but you cannot carry it. Declare a space in your inventory for it.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    // Declare 'sword_weight' as an integer and assign it 10\n    \n    printf(\"Sword weight: %d\\n\", sword_weight);\n    return 0;\n}",
    "success_criteria": {
      "type": "regex_match",
      "regex": "Sword weight: 10"
    },
    "hints": [
      "Use 'int' to declare an integer variable",
      "Assign the value 10 using '='",
      "Example: int x = 5;"
    ],
    "xp_reward": 75,
    "map_file": "maps/L02_empty_backpack.json",
    "challenges": [
      {
        "id": "declare_sword",
        "prompt": "Declare an integer variable 'sword_weight' and set it to 10.",
        "expected_output": "Sword weight: 10",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    // Declare 'sword_weight' as an integer and assign it 10\n    \n    printf(\"Sword weight: %d\\n\", sword_weight);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L03",
    "title": "The Gatekeeper",
    "concept": "if/else",
    "description": "The guard blocks the path. He only respects warriors of level 5 or higher.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int player_level = 6;\n    \n    // Write an if statement to check if player_level >= 5\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "regex_match",
      "regex": "Access granted"
    },
    "hints": [
      "Use 'if (condition) { ... }'",
      "The condition is 'player_level >= 5'",
      "Print 'Access granted' inside the if block"
    ],
    "xp_reward": 100,
    "map_file": "maps/L03_gatekeeper.json",
    "challenges": [
      {
        "id": "check_level",
        "prompt": "Write an if statement to check if player_level is greater than or equal to 5.",
        "expected_output": "Access granted",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int player_level = 6;\n    \n    // Write an if statement to check if player_level >= 5\n    // Print 'Access granted' if true\n    \n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L04",
    "title": "The Repeating Strike",
    "concept": "loops",
    "description": "The training dummy requires 5 hits to break. Don't tire yourself out swinging manually.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    // Use a for loop to print 'Strike!' 5 times\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "output_count",
      "token": "Strike!",
      "count": 5
    },
    "hints": [
      "Use a for loop: for(int i=0; i<5; i++)",
      "Put the printf inside the loop curly braces",
      "Make sure to include \\n"
    ],
    "xp_reward": 125,
    "map_file": "maps/L04_repeating_strike.json",
    "challenges": [
      {
        "id": "loop_strike",
        "prompt": "Use a loop to print 'Strike!' 5 times.",
        "expected_output": "Strike!\nStrike!\nStrike!\nStrike!\nStrike!\n",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    // Use a for loop to print 'Strike!' 5 times\n    \n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L05",
    "title": "Array Fortress",
    "concept": "arrays",
    "description": "A fortress of many rooms. Access each room by its index.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int fortress_rooms[5] = {10, 20, 30, 40, 50};\n    \n    // Access the room at index 2\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "regex_match",
      "regex": "Room 2 contains 30"
    },
    "hints": [
      "Arrays start at index 0",
      "The third element is at index 2",
      "Use fortress_rooms[2]"
    ],
    "xp_reward": 200,
    "map_file": "maps/L05_array_fortress.json",
    "challenges": [
      {
        "id": "access_index",
        "prompt": "Print the value in the 3rd room (index 2). Format: 'Room 2 contains X'",
        "expected_output": "Room 2 contains 30",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int fortress_rooms[5] = {10, 20, 30, 40, 50};\n    \n    // Access the room at index 2 and print 'Room 2 contains %d'\n    \n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L06",
    "title": "The Spell Scroll",
    "concept": "void functions",
    "description": "The ancient scroll contains a spell, but it must be spoken to activate. Create a function that speaks the incantation.",
    "code_template": "#include <stdio.h>\n\n// Define a void function called 'cast_spell' that prints \"Abracadabra!\"\n\nint main() {\n    cast_spell();\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Abracadabra!\n"
    },
    "hints": [
      "Void functions are defined as: void functionName() { ... }",
      "Use printf inside the function to print the spell",
      "Don't forget the newline \\n"
    ],
    "xp_reward": 150,
    "map_file": "maps/L06_spell_scroll.json",
    "challenges": [
      {
        "id": "cast_spell_void",
        "prompt": "Define and call a void function 'cast_spell' that prints the incantation.",
        "expected_output": "Abracadabra!",
        "starter_code": "#include <stdio.h>\n\n// Define a void function called 'cast_spell' that prints \"Abracadabra!\"\n\nint main() {\n    cast_spell();\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L07",
    "title": "The Damage Calculator",
    "concept": "return values",
    "description": "The enchanting table can calculate weapon damage, but only if you create a formula that returns the result.",
    "code_template": "#include <stdio.h>\n\n// Define a function 'calculate_damage' that takes (int base, int multiplier)\n// and returns base * multiplier\n\nint main() {\n    int damage = calculate_damage(10, 3);\n    printf(\"Damage: %d\\n\", damage);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Damage: 30\n"
    },
    "hints": [
      "Return type goes before function name: int functionName(...)",
      "Use the return keyword to send back a value",
      "return base * multiplier;"
    ],
    "xp_reward": 175,
    "map_file": "maps/L07_damage_calc.json",
    "challenges": [
      {
        "id": "calc_damage_return",
        "prompt": "Implement 'calculate_damage' so the table reports the correct damage.",
        "expected_output": "Damage: 30",
        "starter_code": "#include <stdio.h>\n\n// Define a function 'calculate_damage' that takes (int base, int multiplier)\n// and returns base * multiplier\n\nint main() {\n    int damage = calculate_damage(10, 3);\n    printf(\"Damage: %d\\n\", damage);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L08",
    "title": "The Stack Spire",
    "concept": "stack frames",
    "description": "Each floor of the spire is a function call. Climb up through nested calls, then return back down.",
    "code_template": "#include <stdio.h>\n\nvoid floor_3() {\n    printf(\"Floor 3 - Top!\\n\");\n}\n\nvoid floor_2() {\n    printf(\"Floor 2\\n\");\n    // Call floor_3 here\n}\n\nvoid floor_1() {\n    printf(\"Floor 1\\n\");\n    floor_2();\n}\n\nint main() {\n    printf(\"Ground Floor\\n\");\n    floor_1();\n    printf(\"Back to Ground\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Ground Floor\nFloor 1\nFloor 2\nFloor 3 - Top!\nBack to Ground\n"
    },
    "hints": [
      "Call floor_3() from inside floor_2().",
      "Execution climbs up the call stack and then unwinds.",
      "Match the exact output order, including newlines."
    ],
    "xp_reward": 200,
    "map_file": "maps/L08_stack_spire.json",
    "challenges": [
      {
        "id": "stack_spire_calls",
        "prompt": "Complete the call chain so the hero climbs to Floor 3 and back.",
        "expected_output": "Ground Floor\nFloor 1\nFloor 2\nFloor 3 - Top!\nBack to Ground",
        "starter_code": "#include <stdio.h>\n\nvoid floor_3() {\n    printf(\"Floor 3 - Top!\\n\");\n}\n\nvoid floor_2() {\n    printf(\"Floor 2\\n\");\n    // Call floor_3 here\n}\n\nvoid floor_1() {\n    printf(\"Floor 1\\n\");\n    floor_2();\n}\n\nint main() {\n    printf(\"Ground Floor\\n\");\n    floor_1();\n    printf(\"Back to Ground\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L09",
    "title": "The Global Artifact",
    "concept": "scope",
    "description": "The temple's central artifact is visible from all chambers. But each room has its own treasures only accessible within.",
    "code_template": "#include <stdio.h>\n\n// Declare a global variable 'artifact_power' = 100\n\nvoid east_chamber() {\n    int local_gem = 10;\n    printf(\"East: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nvoid west_chamber() {\n    int local_gem = 20;\n    printf(\"West: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nint main() {\n    east_chamber();\n    west_chamber();\n    printf(\"Center: artifact=%d\\n\", artifact_power);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "East: artifact=100, gem=10\nWest: artifact=100, gem=20\nCenter: artifact=100\n"
    },
    "hints": [
      "Declare 'artifact_power' outside of any function.",
      "Global variables can be used in any function in the file.",
      "Keep each chamber's local_gem variable inside its own function."
    ],
    "xp_reward": 200,
    "map_file": "maps/L09_global_artifact.json",
    "challenges": [
      {
        "id": "global_vs_local_scope",
        "prompt": "Make the artifact power visible in all chambers while keeping gems local.",
        "expected_output": "East: artifact=100, gem=10\nWest: artifact=100, gem=20\nCenter: artifact=100",
        "starter_code": "#include <stdio.h>\n\n// Declare a global variable 'artifact_power' = 100\n\nvoid east_chamber() {\n    int local_gem = 10;\n    printf(\"East: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nvoid west_chamber() {\n    int local_gem = 20;\n    printf(\"West: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nint main() {\n    east_chamber();\n    west_chamber();\n    printf(\"Center: artifact=%d\\n\", artifact_power);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L10",
    "title": "The Recursive Mirror",
    "concept": "recursion",
    "description": "The mirror shows infinite reflections... but there must be a stopping point, or you'll be trapped forever!",
    "code_template": "#include <stdio.h>\n\nvoid reflect(int depth) {\n    if (depth <= 0) {\n        printf(\"Base reflection reached!\\n\");\n        return;\n    }\n    printf(\"Reflection depth: %d\\n\", depth);\n    // Call reflect with depth - 1\n}\n\nint main() {\n    reflect(3);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Reflection depth: 3\nReflection depth: 2\nReflection depth: 1\nBase reflection reached!\n"
    },
    "hints": [
      "Always include a base case to stop recursion.",
      "Call reflect(depth - 1) to move toward the base case.",
      "Make sure you print at each depth before the recursive call."
    ],
    "xp_reward": 250,
    "map_file": "maps/L10_recursive_mirror.json",
    "challenges": [
      {
        "id": "recursive_reflection",
        "prompt": "Complete the recursive call so the reflections count down to the base case.",
        "expected_output": "Reflection depth: 3\nReflection depth: 2\nReflection depth: 1\nBase reflection reached!",
        "starter_code": "#include <stdio.h>\n\nvoid reflect(int depth) {\n    if (depth <= 0) {\n        printf(\"Base reflection reached!\\n\");\n        return;\n    }\n    printf(\"Reflection depth: %d\\n\", depth);\n    // Call reflect with depth - 1\n}\n\nint main() {\n    reflect(3);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L11",
    "title": "The Address Spell",
    "concept": "address-of operator",
    "description": "To locate the hidden treasure, you must discover its exact address in the memory realm.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    // Print the ADDRESS of treasure using &\n    // Format: printf(\"%p\\n\", ...);\n    return 0;\n}",
    "success_criteria": {
      "type": "compile_only"
    },
    "hints": [
      "Use the & operator to get the address of a variable.",
      "Print addresses with %p and cast to (void*).",
      "The exact address changes each run; we only require compilation."
    ],
    "xp_reward": 225,
    "map_file": "maps/L11_address_spell.json",
    "challenges": [
      {
        "id": "print_address",
        "prompt": "Reveal the memory address of the treasure using the address-of operator.",
        "expected_output": "(varies)",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    // Print the ADDRESS of treasure using & and %p\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L12",
    "title": "The Grappling Hook",
    "concept": "pointer declaration",
    "description": "Your grappling hook can grab distant ledges, but first you must aim it. Declare where it points!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int ledge = 100;\n    // Declare a pointer 'hook' and point it to ledge\n    // Then print the value hook points to\n    printf(\"Grabbed: %d\\n\", *hook);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Grabbed: 100\n"
    },
    "hints": [
      "Declare a pointer with: int *name = &variable;",
      "The * in the declaration means 'pointer to int'.",
      "Use &ledge to get the address of ledge."
    ],
    "xp_reward": 250,
    "map_file": "maps/L12_grappling_hook.json",
    "challenges": [
      {
        "id": "pointer_declare_hook",
        "prompt": "Declare the 'hook' pointer so it grabs the ledge's value.",
        "expected_output": "Grabbed: 100",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int ledge = 100;\n    // Declare a pointer 'hook' and point it to ledge\n    // Then print the value hook points to\n    printf(\"Grabbed: %d\\n\", *hook);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L13",
    "title": "The Dereference Pull",
    "concept": "dereference operator",
    "description": "The treasure is behind a barrier. Use your pointer to pull its value to you!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int hidden_treasure = 777;\n    int *ptr = &hidden_treasure;\n    \n    // Change the treasure's value to 999 using the pointer\n    // Then print it\n    printf(\"Treasure value: %d\\n\", hidden_treasure);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Treasure value: 999\n"
    },
    "hints": [
      "Use *ptr on the left side of = to change the value.",
      "ptr stores an address; *ptr reads or writes the value at that address.",
      "After updating through the pointer, printing hidden_treasure shows the new value."
    ],
    "xp_reward": 275,
    "map_file": "maps/L13_dereference_pull.json",
    "challenges": [
      {
        "id": "dereference_update",
        "prompt": "Use the pointer to change the treasure's value to 999.",
        "expected_output": "Treasure value: 999",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int hidden_treasure = 777;\n    int *ptr = &hidden_treasure;\n    \n    // Change the treasure's value to 999 using the pointer\n    // Then print it\n    printf(\"Treasure value: %d\\n\", hidden_treasure);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L14",
    "title": "The Array Navigator",
    "concept": "pointer arithmetic",
    "description": "The corridor has numbered chambers. Navigate to chamber 3 using pointer arithmetic.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int chambers[5] = {10, 20, 30, 40, 50};\n    int *ptr = chambers;  // Points to first element\n    \n    // Use pointer arithmetic to print the 4th chamber (index 3)\n    // Hint: *(ptr + 3) or ptr[3]\n    printf(\"Chamber 3 contains: %d\\n\", ???);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Chamber 3 contains: 40\n"
    },
    "hints": [
      "Adding 1 to a pointer moves it to the next array element.",
      "ptr[3] is the same as *(ptr + 3).",
      "Index 3 is the 4th chamber in the corridor."
    ],
    "xp_reward": 300,
    "map_file": "maps/L14_array_navigator.json",
    "challenges": [
      {
        "id": "pointer_arithmetic_navigate",
        "prompt": "Use pointer arithmetic to read the value in chamber 3 (index 3).",
        "expected_output": "Chamber 3 contains: 40",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int chambers[5] = {10, 20, 30, 40, 50};\n    int *ptr = chambers;  // Points to first element\n    \n    // Use pointer arithmetic to print the 4th chamber (index 3)\n    // Hint: *(ptr + 3) or ptr[3]\n    printf(\"Chamber 3 contains: %d\\n\", ???);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L15",
    "title": "The Null Trap",
    "concept": "null pointers",
    "description": "Some paths lead to void. Check before you step, or face a SEGFAULT!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    int *safe_ptr = &treasure;\n    int *trap_ptr = NULL;\n    \n    // Safely print values - check for NULL first!\n    // If pointer is NULL, print \"Path is blocked!\"\n    // If pointer is valid, print \"Found: X\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Found: 42\nPath is blocked!\n"
    },
    "hints": [
      "Compare pointers to NULL before dereferencing.",
      "Print one line for the safe path and one for the trap.",
      "Use if/else to choose which message to print."
    ],
    "xp_reward": 350,
    "map_file": "maps/L15_null_trap.json",
    "challenges": [
      {
        "id": "null_pointer_check",
        "prompt": "Check each pointer before using it so you avoid the null trap.",
        "expected_output": "Found: 42\nPath is blocked!",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    int *safe_ptr = &treasure;\n    int *trap_ptr = NULL;\n    \n    // Safely print values - check for NULL first!\n    // If pointer is NULL, print \"Path is blocked!\"\n    // If pointer is valid, print \"Found: X\"\n    \n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L16",
    "title": "The Blueprint Scroll",
    "concept": "struct definition",
    "description": "The ancient scroll contains a blueprint for creating heroes. Define the structure that holds a warrior's attributes.",
    "code_template": "#include <stdio.h>\n\n// Define a struct 'Hero' with:\n// - char name[50]\n// - int hp\n// - int level\n\nint main() {\n    struct Hero warrior = {\"Valor\", 100, 5};\n    printf(\"Hero: %s, HP: %d, Level: %d\\n\", warrior.name, warrior.hp, warrior.level);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Hero: Valor, HP: 100, Level: 5\n"
    },
    "hints": [
      "Structs group related data together using: struct Name { ... };",
      "Use 'char name[50]' for a string field",
      "Initialize with: struct Hero h = {\"name\", 100, 5};"
    ],
    "xp_reward": 300,
    "map_file": "maps/L16_blueprint_scroll.json",
    "challenges": [
      {
        "id": "define_hero_struct",
        "prompt": "Define the Hero struct with name, hp, and level fields.",
        "expected_output": "Hero: Valor, HP: 100, Level: 5",
        "starter_code": "#include <stdio.h>\n\n// Define a struct 'Hero' with name, hp, and level\n\nint main() {\n    struct Hero warrior = {\"Valor\", 100, 5};\n    printf(\"Hero: %s, HP: %d, Level: %d\\n\", warrior.name, warrior.hp, warrior.level);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L17",
    "title": "The Chest Contents",
    "concept": "struct members",
    "description": "You found a treasure chest! Use dot notation to access and modify its contents.",
    "code_template": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint main() {\n    struct Chest treasure;\n    \n    // Set gold to 500, gems to 10, keys to 3\n    // Then print: \"Chest: X gold, Y gems, Z keys\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Chest: 500 gold, 10 gems, 3 keys\n"
    },
    "hints": [
      "Access struct members with dot notation: chest.gold = 500;",
      "Each field must be set individually",
      "Use %d for integers in printf"
    ],
    "xp_reward": 325,
    "map_file": "maps/L17_chest_contents.json",
    "challenges": [
      {
        "id": "access_struct_members",
        "prompt": "Set the chest contents using dot notation and print the result.",
        "expected_output": "Chest: 500 gold, 10 gems, 3 keys",
        "starter_code": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint main() {\n    struct Chest treasure;\n    // Set gold=500, gems=10, keys=3 using dot notation\n    // Print: \"Chest: X gold, Y gems, Z keys\"\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L18",
    "title": "The Teleport Chest",
    "concept": "struct pointers",
    "description": "The chest is behind a magical barrier. Use a pointer to reach through and modify its contents!",
    "code_template": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n};\n\nvoid add_gold(struct Chest *c, int amount) {\n    // Use arrow operator to add gold\n}\n\nint main() {\n    struct Chest treasure = {100};\n    add_gold(&treasure, 50);\n    printf(\"Gold: %d\\n\", treasure.gold);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Gold: 150\n"
    },
    "hints": [
      "Use the arrow operator (->) to access members through a pointer",
      "c->gold is equivalent to (*c).gold",
      "Add the amount to the existing gold: c->gold += amount;"
    ],
    "xp_reward": 350,
    "map_file": "maps/L18_teleport_chest.json",
    "challenges": [
      {
        "id": "struct_pointer_arrow",
        "prompt": "Use the arrow operator to modify the chest through a pointer.",
        "expected_output": "Gold: 150",
        "starter_code": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n};\n\nvoid add_gold(struct Chest *c, int amount) {\n    // Use -> to add gold\n}\n\nint main() {\n    struct Chest treasure = {100};\n    add_gold(&treasure, 50);\n    printf(\"Gold: %d\\n\", treasure.gold);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L19",
    "title": "The Guild Hierarchy",
    "concept": "nested structs",
    "description": "The guild has a hierarchy. Each guild has a leader, and the leader is also a hero with their own attributes.",
    "code_template": "#include <stdio.h>\n\nstruct Hero {\n    char name[50];\n    int level;\n};\n\nstruct Guild {\n    char guild_name[50];\n    struct Hero leader;\n    int member_count;\n};\n\nint main() {\n    struct Guild warriors = {\"Iron Fist\", {\"Maximus\", 50}, 100};\n    \n    // Print: \"Guild: X, Leader: Y (Lv.Z), Members: N\"\n    printf(\"Guild: %s, Leader: %s (Lv.%d), Members: %d\\n\",\n           ???);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Guild: Iron Fist, Leader: Maximus (Lv.50), Members: 100\n"
    },
    "hints": [
      "Access nested struct members with multiple dots: guild.leader.name",
      "The leader is a Hero struct inside the Guild struct",
      "Use warriors.guild_name, warriors.leader.name, etc."
    ],
    "xp_reward": 375,
    "map_file": "maps/L19_guild_hierarchy.json",
    "challenges": [
      {
        "id": "nested_struct_access",
        "prompt": "Access the nested Hero struct inside Guild to print the hierarchy.",
        "expected_output": "Guild: Iron Fist, Leader: Maximus (Lv.50), Members: 100",
        "starter_code": "#include <stdio.h>\n\nstruct Hero {\n    char name[50];\n    int level;\n};\n\nstruct Guild {\n    char guild_name[50];\n    struct Hero leader;\n    int member_count;\n};\n\nint main() {\n    struct Guild warriors = {\"Iron Fist\", {\"Maximus\", 50}, 100};\n    // Print the guild info using nested access\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L20",
    "title": "The Army Roster",
    "concept": "array of structs",
    "description": "The army needs a roster! Create an array of soldiers and iterate through them.",
    "code_template": "#include <stdio.h>\n\nstruct Soldier {\n    char name[20];\n    int strength;\n};\n\nint main() {\n    struct Soldier army[3] = {\n        {\"Grunt\", 10},\n        {\"Knight\", 25},\n        {\"Champion\", 50}\n    };\n    \n    // Loop through and print each soldier\n    // Format: \"Soldier: X, Strength: Y\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Soldier: Grunt, Strength: 10\nSoldier: Knight, Strength: 25\nSoldier: Champion, Strength: 50\n"
    },
    "hints": [
      "Use a for loop: for(int i = 0; i < 3; i++)",
      "Access array elements with: army[i].name",
      "Each iteration prints one soldier"
    ],
    "xp_reward": 400,
    "map_file": "maps/L20_army_roster.json",
    "challenges": [
      {
        "id": "array_of_structs_loop",
        "prompt": "Loop through the army array and print each soldier.",
        "expected_output": "Soldier: Grunt, Strength: 10\nSoldier: Knight, Strength: 25\nSoldier: Champion, Strength: 50",
        "starter_code": "#include <stdio.h>\n\nstruct Soldier {\n    char name[20];\n    int strength;\n};\n\nint main() {\n    struct Soldier army[3] = {\n        {\"Grunt\", 10},\n        {\"Knight\", 25},\n        {\"Champion\", 50}\n    };\n    // Loop and print each soldier\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L21",
    "title": "Summon Land",
    "concept": "malloc basics",
    "description": "The void stretches before you. Use malloc to summon solid ground from nothingness!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate memory for one integer using malloc\n    int *land = ???;\n    \n    *land = 42;\n    printf(\"Land summoned with value: %d\\n\", *land);\n    \n    free(land);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Land summoned with value: 42\n"
    },
    "hints": [
      "malloc returns a pointer to allocated memory",
      "Use: int *ptr = (int*)malloc(sizeof(int));",
      "sizeof(int) tells malloc how many bytes to allocate"
    ],
    "xp_reward": 425,
    "map_file": "maps/L21_summon_land.json",
    "challenges": [
      {
        "id": "malloc_single_int",
        "prompt": "Use malloc to allocate space for one integer.",
        "expected_output": "Land summoned with value: 42",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate memory for one integer\n    int *land = ???;\n    *land = 42;\n    printf(\"Land summoned with value: %d\\n\", *land);\n    free(land);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L22",
    "title": "The Banish Spell",
    "concept": "free memory",
    "description": "What you summon, you must also banish! Release the memory back to the void.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *summoned = (int*)malloc(sizeof(int));\n    *summoned = 999;\n    printf(\"Value before banish: %d\\n\", *summoned);\n    \n    // Free the memory here\n    \n    printf(\"Memory banished!\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Value before banish: 999\nMemory banished!\n"
    },
    "hints": [
      "Use free(pointer) to release allocated memory",
      "Always free memory that was malloc'd",
      "After free, don't use the pointer again"
    ],
    "xp_reward": 450,
    "map_file": "maps/L22_banish_spell.json",
    "challenges": [
      {
        "id": "free_memory",
        "prompt": "Free the allocated memory using the free function.",
        "expected_output": "Value before banish: 999\nMemory banished!",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *summoned = (int*)malloc(sizeof(int));\n    *summoned = 999;\n    printf(\"Value before banish: %d\\n\", *summoned);\n    // Free the memory\n    printf(\"Memory banished!\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L23",
    "title": "The Cursed Hoarding",
    "concept": "memory leaks",
    "description": "A curse afflicts those who hoard without releasing! Find and fix the memory leak.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    for(int i = 0; i < 3; i++) {\n        int *treasure = (int*)malloc(sizeof(int));\n        *treasure = (i + 1) * 100;\n        printf(\"Found treasure: %d\\n\", *treasure);\n        // FIX: Free memory inside the loop!\n    }\n    printf(\"All treasures collected properly!\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Found treasure: 100\nFound treasure: 200\nFound treasure: 300\nAll treasures collected properly!\n"
    },
    "hints": [
      "Memory allocated inside a loop should be freed inside the loop",
      "Each malloc needs a matching free",
      "Add free(treasure) before the loop iteration ends"
    ],
    "xp_reward": 475,
    "map_file": "maps/L23_cursed_hoarding.json",
    "challenges": [
      {
        "id": "fix_memory_leak",
        "prompt": "Add the missing free() call to prevent the memory leak.",
        "expected_output": "Found treasure: 100\nFound treasure: 200\nFound treasure: 300\nAll treasures collected properly!",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    for(int i = 0; i < 3; i++) {\n        int *treasure = (int*)malloc(sizeof(int));\n        *treasure = (i + 1) * 100;\n        printf(\"Found treasure: %d\\n\", *treasure);\n        // Add free here\n    }\n    printf(\"All treasures collected properly!\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L24",
    "title": "The Expanding Army",
    "concept": "dynamic arrays",
    "description": "Your army grows! Use realloc to expand the barracks when new recruits arrive.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *army = (int*)malloc(2 * sizeof(int));\n    army[0] = 10;\n    army[1] = 20;\n    printf(\"Army size 2: %d, %d\\n\", army[0], army[1]);\n    \n    // Expand to size 4 using realloc\n    army = ???;\n    army[2] = 30;\n    army[3] = 40;\n    printf(\"Army size 4: %d, %d, %d, %d\\n\", army[0], army[1], army[2], army[3]);\n    \n    free(army);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Army size 2: 10, 20\nArmy size 4: 10, 20, 30, 40\n"
    },
    "hints": [
      "realloc can grow or shrink allocated memory",
      "Use: ptr = (int*)realloc(ptr, new_size);",
      "realloc preserves existing data"
    ],
    "xp_reward": 500,
    "map_file": "maps/L24_expanding_army.json",
    "challenges": [
      {
        "id": "realloc_expand",
        "prompt": "Use realloc to expand the army array from 2 to 4 elements.",
        "expected_output": "Army size 2: 10, 20\nArmy size 4: 10, 20, 30, 40",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *army = (int*)malloc(2 * sizeof(int));\n    army[0] = 10;\n    army[1] = 20;\n    printf(\"Army size 2: %d, %d\\n\", army[0], army[1]);\n    // Expand to size 4\n    army[2] = 30;\n    army[3] = 40;\n    printf(\"Army size 4: %d, %d, %d, %d\\n\", army[0], army[1], army[2], army[3]);\n    free(army);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L25",
    "title": "Chain of Portals",
    "concept": "linked lists",
    "description": "Create a chain of magical portals, each pointing to the next. This is the foundation of linked lists!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Portal {\n    int destination;\n    struct Portal *next;\n};\n\nint main() {\n    // Create 3 portals: 10 -> 20 -> 30 -> NULL\n    struct Portal *first = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *second = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *third = (struct Portal*)malloc(sizeof(struct Portal));\n    \n    first->destination = 10;\n    first->next = second;\n    \n    second->destination = 20;\n    // Link second to third\n    \n    third->destination = 30;\n    third->next = NULL;\n    \n    // Traverse and print\n    struct Portal *current = first;\n    while(current != NULL) {\n        printf(\"Portal to: %d\\n\", current->destination);\n        current = current->next;\n    }\n    \n    free(first); free(second); free(third);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Portal to: 10\nPortal to: 20\nPortal to: 30\n"
    },
    "hints": [
      "Link nodes with: node->next = another_node;",
      "The last node's next should be NULL",
      "Traverse with: while(current != NULL) { ... current = current->next; }"
    ],
    "xp_reward": 550,
    "map_file": "maps/L25_chain_portals.json",
    "challenges": [
      {
        "id": "linked_list_basic",
        "prompt": "Complete the portal chain by linking second to third.",
        "expected_output": "Portal to: 10\nPortal to: 20\nPortal to: 30",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Portal {\n    int destination;\n    struct Portal *next;\n};\n\nint main() {\n    struct Portal *first = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *second = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *third = (struct Portal*)malloc(sizeof(struct Portal));\n    \n    first->destination = 10;\n    first->next = second;\n    \n    second->destination = 20;\n    // Link second to third\n    \n    third->destination = 30;\n    third->next = NULL;\n    \n    struct Portal *current = first;\n    while(current != NULL) {\n        printf(\"Portal to: %d\\n\", current->destination);\n        current = current->next;\n    }\n    \n    free(first); free(second); free(third);\n    return 0;\n}"
      }
    ]
  }
]
