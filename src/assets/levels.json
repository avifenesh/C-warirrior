[
  {
    "id": "L01",
    "title": "The First Spell",
    "theme": "L01_village",
    "concept": "return values",
    "description": "Master the art of returning values to unlock the door ahead. Complete all quests to proceed.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    // Tests will call your function\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L01_first_spell.json",
    "challenges": [],
    "lesson": {
      "title": "Return Values: Your First Spell",
      "content": [
        "In C, functions can send values back to their caller using the 'return' statement.",
        "The return type (like 'int') tells C what kind of value your function will send back.",
        "Think of return as casting a spell that produces a specific result - the value you return is the spell's effect!"
      ],
      "examples": [
        {
          "code": "int getMagicNumber() {\n    return 42;\n}",
          "explanation": "This function returns the integer 42. Simple and direct!"
        },
        {
          "code": "int addSpells(int a, int b) {\n    return a + b;\n}",
          "explanation": "You can return the result of calculations. This returns the sum of a and b."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 192,
          "y": 224,
          "quest_id": "L01_Q1"
        },
        {
          "x": 320,
          "y": 224,
          "quest_id": "L01_Q2"
        },
        {
          "x": 448,
          "y": 224,
          "quest_id": "L01_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L01_Q1",
        "order": 1,
        "title": "The Secret Number",
        "description": "Return the secret number 42 to prove your worth.",
        "recommended": true,
        "function_signature": {
          "name": "getSecret",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getSecret() {\n    // Return the secret number: 42\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "42",
            "sample": true
          }
        ],
        "hints": [
          "Use the 'return' keyword to send a value back",
          "Example: return 42;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L01_Q2",
        "order": 2,
        "title": "Double Trouble",
        "description": "The merchant wants twice his stock of 50 items. Return the doubled amount!",
        "recommended": false,
        "function_signature": {
          "name": "getDouble",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getDouble() {\n    // Return 50 multiplied by 2\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "100",
            "sample": true
          }
        ],
        "hints": [
          "You can use arithmetic in return statements",
          "Example: return 50 * 2;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L01_Q3",
        "order": 3,
        "title": "The Sum Spell",
        "description": "Combine three power crystals: 25, 35, and 15 energy units. Return their combined power!",
        "recommended": false,
        "function_signature": {
          "name": "getSum",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getSum() {\n    // Return 25 + 35 + 15\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "75",
            "sample": true
          }
        ],
        "hints": [
          "Add numbers with the + operator",
          "Example: return 25 + 35 + 15;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L02",
    "title": "The Empty Backpack",
    "theme": "L02_market",
    "concept": "variables",
    "description": "The merchant needs help with calculations. Master arithmetic with parameters!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L02_empty_backpack.json",
    "challenges": [],
    "lesson": {
      "title": "Variables and Arithmetic",
      "content": [
        "Variables store data that your program can use and modify. In C, you must declare a variable's type before using it.",
        "Function parameters are special variables that receive values when the function is called.",
        "Arithmetic operators like + (add), - (subtract), * (multiply), and / (divide) work with numeric variables."
      ],
      "examples": [
        {
          "code": "int add(int x, int y) {\n    return x + y;\n}",
          "explanation": "Parameters x and y receive values from the caller, and we return their sum."
        },
        {
          "code": "int double(int n) {\n    return n * 2;\n}",
          "explanation": "We can perform arithmetic on parameters and return the result."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L02_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L02_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L02_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L02_Q1",
        "order": 1,
        "title": "Adding Weights",
        "description": "The merchant needs to calculate the total weight of two items.",
        "recommended": true,
        "function_signature": {
          "name": "addWeight",
          "return_type": "int",
          "parameters": [
            {
              "name": "item1",
              "type": "int"
            },
            {
              "name": "item2",
              "type": "int"
            }
          ]
        },
        "user_template": "int addWeight(int item1, int item2) {\n    // Return the sum of item1 and item2\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              25
            ],
            "expected": "35",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              100,
              200
            ],
            "expected": "300",
            "sample": false
          },
          {
            "input": [
              0,
              42
            ],
            "expected": "42",
            "sample": false
          }
        ],
        "hints": [
          "Use the + operator to add numbers",
          "Return the sum: return item1 + item2;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L02_Q2",
        "order": 2,
        "title": "Calculate Area",
        "description": "Find the area of a rectangular storage crate.",
        "recommended": false,
        "function_signature": {
          "name": "calculateArea",
          "return_type": "int",
          "parameters": [
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "height",
              "type": "int"
            }
          ]
        },
        "user_template": "int calculateArea(int width, int height) {\n    // Return width multiplied by height\n    \n}",
        "test_cases": [
          {
            "input": [
              3,
              4
            ],
            "expected": "12",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "25",
            "sample": true
          },
          {
            "input": [
              1,
              100
            ],
            "expected": "100",
            "sample": false
          },
          {
            "input": [
              10,
              10
            ],
            "expected": "100",
            "sample": false
          }
        ],
        "hints": [
          "Use the * operator to multiply",
          "Area = width * height"
        ],
        "xp_reward": 30
      },
      {
        "id": "L02_Q3",
        "order": 3,
        "title": "Triple Sum",
        "description": "Sum three item weights for the heavy load calculation.",
        "recommended": false,
        "function_signature": {
          "name": "tripleSum",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "user_template": "int tripleSum(int a, int b, int c) {\n    // Return the sum of all three values\n    \n}",
        "test_cases": [
          {
            "input": [
              1,
              2,
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              10,
              20,
              30
            ],
            "expected": "60",
            "sample": true
          },
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              200,
              300
            ],
            "expected": "600",
            "sample": false
          }
        ],
        "hints": [
          "Chain additions: a + b + c",
          "Example: return a + b + c;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L03",
    "title": "The Gatekeeper",
    "theme": "L03_tower",
    "concept": "if/else",
    "description": "The guard tests your logic. Prove your worth with conditional decisions!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L03_gatekeeper.json",
    "challenges": [],
    "lesson": {
      "title": "Conditional Logic with if/else",
      "content": [
        "Programs often need to make decisions. The if/else statement lets your code choose between different paths based on conditions.",
        "A condition is an expression that evaluates to true or false. Comparison operators include: > (greater), < (less), >= (greater or equal), <= (less or equal), == (equal), != (not equal).",
        "The if block runs when the condition is true; the else block runs when it's false."
      ],
      "examples": [
        {
          "code": "int isPositive(int n) {\n    if (n > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
          "explanation": "Returns 1 if n is positive, 0 otherwise."
        },
        {
          "code": "int bigger(int a, int b) {\n    if (a > b) {\n        return a;\n    }\n    return b;\n}",
          "explanation": "Returns a if it's bigger, otherwise returns b."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L03_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L03_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L03_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L03_Q1",
        "order": 1,
        "title": "Maximum Value",
        "description": "Return the larger of two numbers to impress the guard.",
        "recommended": true,
        "function_signature": {
          "name": "maxValue",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            }
          ]
        },
        "user_template": "int maxValue(int a, int b) {\n    // Return the larger of a and b\n    \n}",
        "test_cases": [
          {
            "input": [
              3,
              7
            ],
            "expected": "7",
            "sample": true
          },
          {
            "input": [
              10,
              2
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "5",
            "sample": false
          },
          {
            "input": [
              -3,
              -7
            ],
            "expected": "-3",
            "sample": false
          }
        ],
        "hints": [
          "Use if (a > b) to compare",
          "Return the larger value in each branch"
        ],
        "xp_reward": 30
      },
      {
        "id": "L03_Q2",
        "order": 2,
        "title": "Even or Odd",
        "description": "Determine if a number is even (return 1) or odd (return 0).",
        "recommended": false,
        "function_signature": {
          "name": "isEven",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int isEven(int n) {\n    // Return 1 if n is even, 0 if odd\n    \n}",
        "test_cases": [
          {
            "input": [
              4
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              7
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              -2
            ],
            "expected": "1",
            "sample": false
          }
        ],
        "hints": [
          "Use the modulo operator: n % 2",
          "Even numbers have n % 2 == 0"
        ],
        "xp_reward": 35
      },
      {
        "id": "L03_Q3",
        "order": 3,
        "title": "Clamp Value",
        "description": "Keep a value within bounds: if below min, return min; if above max, return max.",
        "recommended": false,
        "function_signature": {
          "name": "clamp",
          "return_type": "int",
          "parameters": [
            {
              "name": "value",
              "type": "int"
            },
            {
              "name": "min",
              "type": "int"
            },
            {
              "name": "max",
              "type": "int"
            }
          ]
        },
        "user_template": "int clamp(int value, int min, int max) {\n    // Return value bounded between min and max\n    \n}",
        "test_cases": [
          {
            "input": [
              5,
              0,
              10
            ],
            "expected": "5",
            "sample": true
          },
          {
            "input": [
              -5,
              0,
              10
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              15,
              0,
              10
            ],
            "expected": "10",
            "sample": false
          },
          {
            "input": [
              50,
              0,
              100
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "Check if value < min first",
          "Then check if value > max",
          "Otherwise return value unchanged"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L04",
    "title": "The Repeating Strike",
    "theme": "L04_forest",
    "concept": "loops",
    "description": "Master the art of repetition with for loops!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 120,
    "map_file": "maps/L04_forest.json",
    "challenges": [],
    "lesson": {
      "title": "Loops for Repetition",
      "content": [
        "Loops let you repeat code multiple times. The for loop is perfect when you know how many times to repeat.",
        "A for loop has three parts: initialization (int i = 1), condition (i <= n), and update (i++).",
        "The loop body executes repeatedly while the condition is true. Use a variable to accumulate results across iterations."
      ],
      "examples": [
        {
          "code": "int countTo(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum = sum + i;\n    }\n    return sum;\n}",
          "explanation": "This loop adds 1+2+3+...+n by accumulating each value."
        },
        {
          "code": "int multiply(int base, int times) {\n    int result = 0;\n    for (int i = 0; i < times; i++) {\n        result = result + base;\n    }\n    return result;\n}",
          "explanation": "Multiplication through repeated addition."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L04_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L04_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L04_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L04_Q1",
        "order": 1,
        "title": "Sum of Strikes",
        "description": "Calculate the sum of all strikes from 1 to n.",
        "recommended": true,
        "function_signature": {
          "name": "sumStrikes",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int sumStrikes(int n) {\n    // Return the sum of 1 + 2 + 3 + ... + n\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "15",
            "sample": true
          },
          {
            "input": [
              10
            ],
            "expected": "55",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              100
            ],
            "expected": "5050",
            "sample": false
          }
        ],
        "hints": [
          "Use a for loop: for(int i = 1; i <= n; i++)",
          "Accumulate: sum = sum + i"
        ],
        "xp_reward": 35
      },
      {
        "id": "L04_Q2",
        "order": 2,
        "title": "Factorial",
        "description": "Compute n! (n factorial = n \u00d7 (n-1) \u00d7 ... \u00d7 1).",
        "recommended": false,
        "function_signature": {
          "name": "factorial",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int factorial(int n) {\n    // Return n! = n * (n-1) * ... * 1\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "120",
            "sample": true
          },
          {
            "input": [
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              0
            ],
            "expected": "1",
            "sample": false
          }
        ],
        "hints": [
          "Start with result = 1",
          "Multiply: result = result * i"
        ],
        "xp_reward": 40
      },
      {
        "id": "L04_Q3",
        "order": 3,
        "title": "Count Divisible",
        "description": "Count how many numbers from 1 to n are divisible by d.",
        "recommended": false,
        "function_signature": {
          "name": "countDivisible",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            },
            {
              "name": "d",
              "type": "int"
            }
          ]
        },
        "user_template": "int countDivisible(int n, int d) {\n    // Count numbers from 1 to n divisible by d\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              2
            ],
            "expected": "5",
            "sample": true
          },
          {
            "input": [
              10,
              3
            ],
            "expected": "3",
            "sample": true
          },
          {
            "input": [
              5,
              7
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              10
            ],
            "expected": "10",
            "sample": false
          }
        ],
        "hints": [
          "Use if inside the loop",
          "Check: if (i % d == 0) count++"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L05",
    "title": "Array Fortress",
    "theme": "L05_darkwoods",
    "concept": "arrays",
    "description": "A fortress of many rooms. Master array access and iteration!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L05_darkwoods.json",
    "challenges": [],
    "lesson": {
      "title": "Arrays: Collections of Data",
      "content": [
        "Arrays let you store multiple values of the same type in a single variable. Each value has an index (position number).",
        "IMPORTANT: Array indices start at 0! The first element is at index 0, the second at index 1, and so on.",
        "Access array elements with square brackets: arr[0] gets the first element, arr[2] gets the third."
      ],
      "examples": [
        {
          "code": "int getFirst() {\n    int rooms[3] = {10, 20, 30};\n    return rooms[0];\n}",
          "explanation": "Returns 10 - the element at index 0 (first position)."
        },
        {
          "code": "int getThird() {\n    int data[5] = {5, 10, 15, 20, 25};\n    return data[2];\n}",
          "explanation": "Returns 15 - the element at index 2 (third position)."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L05_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L05_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L05_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L05_Q1",
        "order": 1,
        "title": "Room Access",
        "description": "Return the value at a specific room index from {10, 20, 30, 40, 50}.",
        "recommended": true,
        "function_signature": {
          "name": "getRoom",
          "return_type": "int",
          "parameters": [
            {
              "name": "index",
              "type": "int"
            }
          ]
        },
        "user_template": "int getRoom(int index) {\n    int rooms[5] = {10, 20, 30, 40, 50};\n    // Return the element at 'index'\n    \n}",
        "test_cases": [
          {
            "input": [
              0
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              2
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              4
            ],
            "expected": "50",
            "sample": false
          },
          {
            "input": [
              1
            ],
            "expected": "20",
            "sample": false
          }
        ],
        "hints": [
          "Use rooms[index] to access the element",
          "Array indices start at 0"
        ],
        "xp_reward": 30
      },
      {
        "id": "L05_Q2",
        "order": 2,
        "title": "Sum All Rooms",
        "description": "Sum all elements in the rooms array {10, 20, 30, 40, 50}.",
        "recommended": false,
        "function_signature": {
          "name": "sumRooms",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int sumRooms() {\n    int rooms[5] = {10, 20, 30, 40, 50};\n    // Return the sum of all elements\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "150",
            "sample": true
          }
        ],
        "hints": [
          "Use a for loop to iterate through the array",
          "for (int i = 0; i < 5; i++) sum += rooms[i]"
        ],
        "xp_reward": 35
      },
      {
        "id": "L05_Q3",
        "order": 3,
        "title": "Find Maximum",
        "description": "Find the maximum value in {15, 42, 8, 23, 31}.",
        "recommended": false,
        "function_signature": {
          "name": "findMax",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int findMax() {\n    int values[5] = {15, 42, 8, 23, 31};\n    // Return the maximum value\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "42",
            "sample": true
          }
        ],
        "hints": [
          "Start with max = values[0]",
          "Compare each element: if (values[i] > max) max = values[i]"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L06",
    "title": "The Spell Scroll",
    "theme": "L06_river",
    "concept": "void functions",
    "description": "Learn to create functions that perform actions without returning values.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L06_river.json",
    "challenges": [],
    "lesson": {
      "title": "Void Functions: Actions Without Returns",
      "content": [
        "Not all functions need to return a value. Void functions perform actions (like printing or modifying data) without returning anything.",
        "Declare with 'void' as the return type: void functionName() { }",
        "Void functions are perfect for side effects: printing output, modifying values through pointers, or triggering events.",
        "In these quests, you'll use void helpers to demonstrate the concept, then wrap them in testable functions that return confirmation values."
      ],
      "examples": [
        {
          "code": "void printSpell() {\n    printf(\"Magic!\\n\");\n}\n\nint castSpell() {\n    printSpell();  // Call the void function\n    return 1;      // Confirm it worked\n}",
          "explanation": "The void function performs the action (printing), and the wrapper returns a value we can test."
        },
        {
          "code": "void addBonus(int *value, int bonus) {\n    *value += bonus;\n}\n\nint applyBonus(int base, int bonus) {\n    addBonus(&base, bonus);\n    return base;\n}",
          "explanation": "The void function modifies through a pointer, and we return the result for testing."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 192,
          "y": 224,
          "quest_id": "L06_Q1"
        },
        {
          "x": 384,
          "y": 224,
          "quest_id": "L06_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L06_Q1",
        "order": 1,
        "title": "Cast Spell",
        "description": "Create a void function that prints the magic word, then call it from a wrapper function.",
        "recommended": true,
        "function_signature": {
          "name": "castSpell",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "// First, create the void function that prints\nvoid printSpell() {\n    // Print \"Abracadabra!\" with a newline\n    \n}\n\n// Then create the wrapper that calls it\nint castSpell() {\n    // Call printSpell() to cast the magic\n    // Return 1 to confirm the spell was cast\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "Abracadabra!\n1",
            "sample": true
          }
        ],
        "hints": [
          "In printSpell(): use printf(\"Abracadabra!\\n\");",
          "In castSpell(): call printSpell(); then return 1;",
          "The void function does the work, the int function confirms it happened"
        ],
        "xp_reward": 30
      },
      {
        "id": "L06_Q2",
        "order": 2,
        "title": "Enchant Weapon",
        "description": "Use a void function to add bonus damage through a pointer, then return the result.",
        "recommended": false,
        "function_signature": {
          "name": "enchantWeapon",
          "return_type": "int",
          "parameters": [
            {
              "name": "baseDamage",
              "type": "int"
            },
            {
              "name": "bonus",
              "type": "int"
            }
          ]
        },
        "user_template": "// First, create a void function that modifies through pointer\nvoid addDamage(int *damage, int bonus) {\n    // Add bonus to the value at the pointer\n    \n}\n\n// Then create the wrapper that uses it\nint enchantWeapon(int baseDamage, int bonus) {\n    // Use addDamage to modify baseDamage\n    // Return the enchanted (modified) damage value\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              5
            ],
            "expected": "15",
            "sample": true
          },
          {
            "input": [
              100,
              25
            ],
            "expected": "125",
            "sample": true
          },
          {
            "input": [
              0,
              10
            ],
            "expected": "10",
            "sample": false
          },
          {
            "input": [
              50,
              0
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "In addDamage(): modify through pointer with *damage += bonus;",
          "In enchantWeapon(): call addDamage(&baseDamage, bonus);",
          "The & operator gets the address of baseDamage so addDamage can modify it",
          "After calling addDamage, baseDamage will have the new value - return it!"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L07",
    "title": "The Damage Calculator",
    "theme": "L07_cavern",
    "concept": "complex return expressions",
    "description": "Master complex return expressions that combine multiple operations.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 105,
    "map_file": "maps/L07_cavern.json",
    "challenges": [],
    "lesson": {
      "title": "Complex Return Expressions",
      "content": [
        "Return statements can contain complex expressions that combine multiple operations.",
        "You can use if/else inside a function to conditionally return different values.",
        "Calculations can be chained together: (a + b + c) * bonus / divisor"
      ],
      "examples": [
        {
          "code": "int netDamage(int attack, int defense) {\n    if (attack > defense)\n        return attack - defense;\n    return 0;\n}",
          "explanation": "Returns the difference if positive, otherwise 0."
        },
        {
          "code": "int bonusSum(int a, int b) {\n    return (a + b) * 11 / 10;\n}",
          "explanation": "Adds values and applies a 10% bonus."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L07_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L07_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L07_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L07_Q1",
        "order": 1,
        "title": "Calculate Damage",
        "description": "Return (base \u00d7 mult) - armor, but never below 0.",
        "recommended": true,
        "function_signature": {
          "name": "damage",
          "return_type": "int",
          "parameters": [
            {
              "name": "base",
              "type": "int"
            },
            {
              "name": "mult",
              "type": "int"
            },
            {
              "name": "armor",
              "type": "int"
            }
          ]
        },
        "user_template": "int damage(int base, int mult, int armor) {\n    // Calculate raw damage: base * mult\n    // If raw > armor, return raw - armor\n    // Otherwise return 0\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              3,
              5
            ],
            "expected": "25",
            "sample": true
          },
          {
            "input": [
              5,
              2,
              20
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              7,
              4,
              10
            ],
            "expected": "18",
            "sample": false
          },
          {
            "input": [
              3,
              3,
              9
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "First calculate: int raw = base * mult;",
          "Then check: if (raw > armor) return raw - armor;",
          "Don't forget to return 0 for the else case"
        ],
        "xp_reward": 35
      },
      {
        "id": "L07_Q2",
        "order": 2,
        "title": "Critical Hit",
        "description": "If isCrit is non-zero, return damage \u00d7 3, else return damage unchanged.",
        "recommended": false,
        "function_signature": {
          "name": "criticalHit",
          "return_type": "int",
          "parameters": [
            {
              "name": "damage",
              "type": "int"
            },
            {
              "name": "isCrit",
              "type": "int"
            }
          ]
        },
        "user_template": "int criticalHit(int damage, int isCrit) {\n    // If isCrit != 0, return damage * 3\n    // Otherwise return damage\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              1
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              10,
              0
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              20,
              5
            ],
            "expected": "60",
            "sample": false
          },
          {
            "input": [
              15,
              0
            ],
            "expected": "15",
            "sample": false
          }
        ],
        "hints": [
          "Use if (isCrit != 0) to check for critical",
          "return damage * 3; for critical, damage for normal"
        ],
        "xp_reward": 35
      },
      {
        "id": "L07_Q3",
        "order": 3,
        "title": "Combo Attack",
        "description": "Return the sum of three hits with a 10% bonus: (hit1 + hit2 + hit3) \u00d7 11 \u00f7 10",
        "recommended": false,
        "function_signature": {
          "name": "combo",
          "return_type": "int",
          "parameters": [
            {
              "name": "hit1",
              "type": "int"
            },
            {
              "name": "hit2",
              "type": "int"
            },
            {
              "name": "hit3",
              "type": "int"
            }
          ]
        },
        "user_template": "int combo(int hit1, int hit2, int hit3) {\n    // Return (hit1 + hit2 + hit3) * 11 / 10\n    // This adds 10% bonus to the total\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              10,
              10
            ],
            "expected": "33",
            "sample": true
          },
          {
            "input": [
              5,
              10,
              15
            ],
            "expected": "33",
            "sample": true
          },
          {
            "input": [
              20,
              20,
              20
            ],
            "expected": "66",
            "sample": false
          },
          {
            "input": [
              7,
              8,
              9
            ],
            "expected": "26",
            "sample": false
          }
        ],
        "hints": [
          "Use parentheses: (hit1 + hit2 + hit3) to sum first",
          "Multiply by 11, then divide by 10 for 10% bonus",
          "Order matters: * before / due to integer division"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L08",
    "title": "The Stack Spire",
    "theme": "L08_mountain",
    "concept": "stack frames",
    "description": "Understand how function calls create stack frames with private workspaces.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 105,
    "map_file": "maps/L08_mountain.json",
    "challenges": [],
    "lesson": {
      "title": "The Call Stack",
      "content": [
        "When a function calls another function, the computer 'pauses' the caller and starts the new function.",
        "Each function call creates a 'stack frame' - a private workspace with its own local variables.",
        "When a function returns, its frame is removed and the caller resumes.",
        "This is like stacking books - the last one added is the first one removed."
      ],
      "examples": [
        {
          "code": "int addOne(int n) {\n    return n + 1;\n}\n\nint addTwo(int n) {\n    return addOne(addOne(n));\n}",
          "explanation": "When addTwo calls addOne, it pauses. Each addOne call gets its own stack frame with its own 'n' parameter."
        },
        {
          "code": "int count = 0;\n\nint increment() {\n    count++;\n    return count;\n}",
          "explanation": "Global variables persist across all frames, while local variables live only in their frame."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L08_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L08_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L08_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L08_Q1",
        "order": 1,
        "title": "Add One",
        "description": "Create a simple helper that adds 1 to a number.",
        "recommended": true,
        "function_signature": {
          "name": "addOne",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int addOne(int n) {\n    // Return n + 1\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              -1
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Simply return n + 1"
        ],
        "xp_reward": 30
      },
      {
        "id": "L08_Q2",
        "order": 2,
        "title": "Double Add One",
        "description": "Call addOne twice: addOne(addOne(n)) to add 2.",
        "recommended": false,
        "function_signature": {
          "name": "doubleAddOne",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int addOne(int n) {\n    return n + 1;\n}\n\nint doubleAddOne(int n) {\n    // Call addOne twice to add 2\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "7",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "2",
            "sample": true
          },
          {
            "input": [
              -2
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Chain the calls: addOne(addOne(n))",
          "This adds 1, then adds 1 again"
        ],
        "xp_reward": 35
      },
      {
        "id": "L08_Q3",
        "order": 3,
        "title": "Track Call Depth",
        "description": "Use a global counter to track the maximum depth of recursive calls.",
        "recommended": false,
        "function_signature": {
          "name": "getMaxDepth",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int depth = 0;\nint maxDepth = 0;\n\nvoid trackDepth(int n) {\n    depth++;  // Enter new frame\n    if (depth > maxDepth) maxDepth = depth;\n    \n    if (n > 1) trackDepth(n - 1);  // Recurse\n    \n    depth--;  // Exit frame\n}\n\nint getMaxDepth(int n) {\n    // Reset counters, call trackDepth, return maxDepth\n    \n}",
        "test_cases": [
          {
            "input": [
              3
            ],
            "expected": "3",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              5
            ],
            "expected": "5",
            "sample": false
          },
          {
            "input": [
              10
            ],
            "expected": "10",
            "sample": false
          }
        ],
        "hints": [
          "Reset both globals: depth = 0; maxDepth = 0;",
          "Call trackDepth(n) to build the stack",
          "Return maxDepth to show how deep the stack went"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L09",
    "title": "The Global Artifact",
    "theme": "L09_ice",
    "concept": "scope",
    "description": "Master variable scope: global, function, and block level visibility.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 105,
    "map_file": "maps/L09_ice.json",
    "challenges": [],
    "lesson": {
      "title": "Variable Scope",
      "content": [
        "C has three levels of scope: GLOBAL (file-level), FUNCTION (parameters and locals), and BLOCK (inside {}).",
        "Global variables (declared outside functions) are visible everywhere in the file.",
        "Function scope includes parameters and variables declared at function level - visible throughout the function.",
        "Block scope variables (declared inside {} like loops) only exist within that block.",
        "If a local variable has the same name as a global, the local 'shadows' the global within its scope."
      ],
      "examples": [
        {
          "code": "int power = 100; // global\n\nint getPower() {\n    return power; // reads global\n}",
          "explanation": "Global scope: Functions can access global variables directly."
        },
        {
          "code": "int blockScope(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        int temp = i * 2;  // block scope\n        result += temp;\n    }\n    // temp doesn't exist here!\n    return result;\n}",
          "explanation": "Block scope: temp only exists inside the loop's {}."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L09_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L09_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L09_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L09_Q1",
        "order": 1,
        "title": "Read Global",
        "description": "Access the global artifact variable (value 100).",
        "recommended": true,
        "function_signature": {
          "name": "readGlobal",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int artifact = 100;  // Global variable\n\nint readGlobal() {\n    // Return the global artifact value\n    \n}",
        "test_cases": [
          {
            "input": [],
            "expected": "100",
            "sample": true
          }
        ],
        "hints": [
          "Simply return artifact;",
          "Global variables are accessible from any function"
        ],
        "xp_reward": 30
      },
      {
        "id": "L09_Q2",
        "order": 2,
        "title": "Local Shadow",
        "description": "A local parameter shadows the global. Return the local value.",
        "recommended": false,
        "function_signature": {
          "name": "localShadow",
          "return_type": "int",
          "parameters": [
            {
              "name": "artifact",
              "type": "int"
            }
          ]
        },
        "user_template": "int artifact = 100;  // Global (shadowed)\n\nint localShadow(int artifact) {\n    // Return the parameter (shadows global)\n    \n}",
        "test_cases": [
          {
            "input": [
              50
            ],
            "expected": "50",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              999
            ],
            "expected": "999",
            "sample": false
          }
        ],
        "hints": [
          "The parameter 'artifact' shadows the global",
          "Return the parameter value"
        ],
        "xp_reward": 35
      },
      {
        "id": "L09_Q3",
        "order": 3,
        "title": "Block Scope Accumulator",
        "description": "Sum values using a block-scoped temp variable that only exists inside the loop.",
        "recommended": false,
        "function_signature": {
          "name": "blockScope",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int blockScope(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        // Declare temp = i * 2 (block scope)\n        // Add temp to result\n    }\n    // temp doesn't exist here - only result remains\n    return result;\n}",
        "test_cases": [
          {
            "input": [
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              5
            ],
            "expected": "20",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              1
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Inside the loop: int temp = i * 2;",
          "Add to result: result += temp;",
          "temp only exists within the for loop's {}"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L10",
    "title": "The Recursive Mirror",
    "theme": "L10_temple",
    "concept": "recursion",
    "description": "Master functions that call themselves with base cases.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 120,
    "map_file": "maps/L10_temple.json",
    "challenges": [],
    "lesson": {
      "title": "Recursion",
      "content": [
        "Recursion is when a function calls itself to solve smaller subproblems.",
        "Every recursive function needs a BASE CASE - the condition that stops recursion.",
        "Ask yourself: 'What's the simplest case I can solve directly?' That's your base case.",
        "Without a base case, recursion never stops - causing a stack overflow crash!",
        "The recursive case breaks the problem into smaller pieces, moving toward the base case."
      ],
      "examples": [
        {
          "code": "int sumTo(int n) {\n    if (n <= 0) return 0;  // base\n    return n + sumTo(n - 1);  // recursive\n}",
          "explanation": "Sums 1 to n by adding n to the sum of 1 to n-1. Base case: n <= 0 returns 0."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L10_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L10_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L10_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L10_Q1",
        "order": 1,
        "title": "Recursive Sum",
        "description": "The mirror reflects your spell, adding its reflection to the original. Sum 1 to n using the mirror's recursive magic.",
        "recommended": true,
        "function_signature": {
          "name": "sumToN",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int sumToN(int n) {\n    // Base case: if n <= 0, return 0\n    // Recursive: return n + sumToN(n - 1)\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "15",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              10
            ],
            "expected": "55",
            "sample": false
          }
        ],
        "hints": [
          "WARNING: Without a base case, the mirror reflects forever - stack overflow crash!",
          "Base case: if (n <= 0) return 0;",
          "Recursive: return n + sumToN(n - 1);"
        ],
        "xp_reward": 35
      },
      {
        "id": "L10_Q2",
        "order": 2,
        "title": "Recursive Power",
        "description": "Each reflection multiplies - mirrors within mirrors create exponential power. Calculate base^exp recursively.",
        "recommended": false,
        "function_signature": {
          "name": "power",
          "return_type": "int",
          "parameters": [
            {
              "name": "base",
              "type": "int"
            },
            {
              "name": "exp",
              "type": "int"
            }
          ]
        },
        "user_template": "int power(int base, int exp) {\n    // Base case: if exp == 0, return 1\n    // Recursive: return base * power(base, exp - 1)\n    \n}",
        "test_cases": [
          {
            "input": [
              2,
              3
            ],
            "expected": "8",
            "sample": true
          },
          {
            "input": [
              3,
              2
            ],
            "expected": "9",
            "sample": true
          },
          {
            "input": [
              5,
              0
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              2,
              10
            ],
            "expected": "1024",
            "sample": false
          }
        ],
        "hints": [
          "WARNING: Missing base case = infinite mirror loop = crash!",
          "Base case: any number to the power 0 is 1",
          "Recursive: multiply base by power(base, exp-1)"
        ],
        "xp_reward": 40
      },
      {
        "id": "L10_Q3",
        "order": 3,
        "title": "Fibonacci",
        "description": "The golden spiral emerges from the fibonacci mirrors. TWO base cases required: fib(0)=0 and fib(1)=1. What happens if you forget one?",
        "recommended": false,
        "function_signature": {
          "name": "fib",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int fib(int n) {\n    // Base cases: fib(0) = 0, fib(1) = 1\n    // Recursive: fib(n) = fib(n-1) + fib(n-2)\n    \n}",
        "test_cases": [
          {
            "input": [
              6
            ],
            "expected": "8",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              10
            ],
            "expected": "55",
            "sample": false
          }
        ],
        "hints": [
          "CRITICAL: Fibonacci needs TWO base cases! Missing one causes infinite recursion!",
          "Base case 1: if (n == 0) return 0;",
          "Base case 2: if (n == 1) return 1;",
          "Recursive: return fib(n-1) + fib(n-2);"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L11",
    "title": "The Address Spell",
    "theme": "L11_library",
    "concept": "address-of operator",
    "description": "Learn to work with memory addresses through pointers.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 55,
    "map_file": "maps/L11_library.json",
    "challenges": [],
    "lesson": {
      "title": "Pointers and Memory Addresses",
      "content": [
        "Every variable in C has a memory address where its value is stored.",
        "A pointer is a variable that holds a memory address. Declare with: int *ptr;",
        "In these quests, you RECEIVE pointers as parameters. In real programs, you also CREATE pointers using the & (address-of) operator.",
        "The & operator gets a variable's address: int val = 42; int *ptr = &val;",
        "When a function receives a pointer parameter, it can read the value at that address using the * (dereference) operator."
      ],
      "examples": [
        {
          "code": "int readValue(int *ptr) {\n    return *ptr;\n}",
          "explanation": "The function receives an address and returns the value stored there using *."
        },
        {
          "code": "int useAddress(int val) {\n    int *ptr = &val;  // Get address with &\n    return *ptr;      // Read value with *\n}",
          "explanation": "Real-world example: Get a variable's address with &, then read through the pointer with *."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L11_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L11_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L11_Q1",
        "order": 1,
        "title": "Read Via Pointer",
        "description": "Return the value stored at the address the pointer points to.",
        "recommended": true,
        "function_signature": {
          "name": "readValue",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int readValue(int *ptr) {\n    // Return the value at the address ptr points to\n    // Use *ptr to dereference the pointer\n    \n}",
        "test_cases": [
          {
            "input": [
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              100
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              -5
            ],
            "expected": "-5",
            "sample": false
          }
        ],
        "hints": [
          "Use *ptr to get the value at the address",
          "Example: return *ptr;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L11_Q2",
        "order": 2,
        "title": "Add Via Pointers",
        "description": "Return the sum of values at two different addresses.",
        "recommended": false,
        "function_signature": {
          "name": "addValues",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int*"
            },
            {
              "name": "b",
              "type": "int*"
            }
          ]
        },
        "user_template": "int addValues(int *a, int *b) {\n    // Return the sum of values at addresses a and b\n    \n}",
        "test_cases": [
          {
            "input": [
              3,
              4
            ],
            "expected": "7",
            "sample": true
          },
          {
            "input": [
              10,
              20
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              -5,
              5
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Dereference both pointers: *a and *b",
          "Return their sum: return *a + *b;"
        ],
        "xp_reward": 30
      }
    ]
  },
  {
    "id": "L12",
    "title": "The Grappling Hook",
    "theme": "L12_crypt",
    "concept": "pointer declaration",
    "description": "Master pointer declarations and learn to grab values from a distance!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L12_crypt.json",
    "challenges": [],
    "lesson": {
      "title": "Declaring and Using Pointers",
      "content": [
        "Declare a pointer with: int *ptr; (a pointer to an integer)",
        "The * in declarations means 'pointer to'. In expressions, * means 'dereference'.",
        "To make a pointer point to a variable, use the & operator: int *ptr = &variable;",
        "This is the FULL pattern: declare pointer, assign address, then use the value.",
        "Functions can modify values through pointers, allowing changes to persist outside the function."
      ],
      "examples": [
        {
          "code": "int getValue(int *ptr) {\n    return *ptr;  // Read value at address\n}",
          "explanation": "Reading a value through a pointer parameter."
        },
        {
          "code": "int useLocalPointer(int val) {\n    int *ptr = &val;  // DECLARE pointer and ASSIGN address\n    return *ptr * 2;  // Use dereferenced value\n}",
          "explanation": "Complete pattern: declare pointer, get address with &, use value with *."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L12_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L12_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L12_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L12_Q1",
        "order": 1,
        "title": "Grab the Value",
        "description": "Return the value your pointer hook is aimed at.",
        "recommended": true,
        "function_signature": {
          "name": "grab",
          "return_type": "int",
          "parameters": [
            {
              "name": "hook",
              "type": "int*"
            }
          ]
        },
        "user_template": "int grab(int *hook) {\n    // Return the value that hook points to\n    \n}",
        "test_cases": [
          {
            "input": [
              100
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Use *hook to dereference the pointer",
          "return *hook;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L12_Q2",
        "order": 2,
        "title": "Double the Treasure",
        "description": "Return double the value at the pointer's location.",
        "recommended": false,
        "function_signature": {
          "name": "doubleTreasure",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int doubleTreasure(int *ptr) {\n    // Return the value at ptr multiplied by 2\n    \n}",
        "test_cases": [
          {
            "input": [
              50
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              7
            ],
            "expected": "14",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Dereference and multiply: *ptr * 2",
          "return *ptr * 2;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L12_Q3",
        "order": 3,
        "title": "Declare Local Pointer",
        "description": "DECLARE a local pointer to val, ASSIGN its address, then return the value doubled.",
        "recommended": false,
        "function_signature": {
          "name": "useLocalPointer",
          "return_type": "int",
          "parameters": [
            {
              "name": "val",
              "type": "int"
            }
          ]
        },
        "user_template": "int useLocalPointer(int val) {\n    // DECLARE a pointer: int *ptr\n    // ASSIGN address: ptr = &val;\n    // Or combine: int *ptr = &val;\n    // Return *ptr doubled\n    \n}",
        "test_cases": [
          {
            "input": [
              10
            ],
            "expected": "20",
            "sample": true
          },
          {
            "input": [
              7
            ],
            "expected": "14",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              -5
            ],
            "expected": "-10",
            "sample": false
          }
        ],
        "hints": [
          "This quest requires DECLARING your own pointer!",
          "int *ptr = &val; creates pointer and gets address",
          "Then use: return *ptr * 2;",
          "Full pattern: declare pointer, assign address with &, use value with *"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L13",
    "title": "The Dereference Pull",
    "theme": "L13_lake",
    "concept": "dereference operator",
    "description": "Learn to modify values through pointers - the key to powerful functions!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L13_lake.json",
    "challenges": [],
    "lesson": {
      "title": "Modifying Values Through Pointers",
      "content": [
        "The dereference operator (*) lets you both read AND write values at an address.",
        "Writing: *ptr = value; changes what ptr points to.",
        "Changes through *ptr persist because you are modifying the ORIGINAL variable at that address.",
        "This is how functions can \"return\" multiple values - by modifying variables through pointers.",
        "This is how functions can modify variables from their caller - by receiving pointers to those variables."
      ],
      "examples": [
        {
          "code": "void setTo42(int *ptr) {\n    *ptr = 42;\n}",
          "explanation": "Sets the value at ptr's address to 42."
        },
        {
          "code": "int setAndReturn(int *ptr, int val) {\n    *ptr = val;\n    return *ptr;\n}",
          "explanation": "Modifies through pointer and returns the new value."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L13_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L13_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L13_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L13_Q1",
        "order": 1,
        "title": "Set and Read",
        "description": "Set the value at ptr to val and return it to confirm the change.",
        "recommended": true,
        "function_signature": {
          "name": "setAndRead",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            },
            {
              "name": "val",
              "type": "int"
            }
          ]
        },
        "user_template": "int setAndRead(int *ptr, int val) {\n    // Set *ptr to val, then return *ptr\n    \n}",
        "test_cases": [
          {
            "input": [
              0,
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              100,
              200
            ],
            "expected": "200",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "5",
            "sample": false
          }
        ],
        "hints": [
          "First set: *ptr = val;",
          "Then return: return *ptr;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L13_Q2",
        "order": 2,
        "title": "Increment Through Pointer",
        "description": "Increase the value at ptr by 1 and return the new value.",
        "recommended": false,
        "function_signature": {
          "name": "incrementAndRead",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int incrementAndRead(int *ptr) {\n    // Add 1 to *ptr and return the new value\n    \n}",
        "test_cases": [
          {
            "input": [
              10
            ],
            "expected": "11",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              -1
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              99
            ],
            "expected": "100",
            "sample": false
          }
        ],
        "hints": [
          "Modify: *ptr = *ptr + 1; or (*ptr)++;",
          "Return the updated value"
        ],
        "xp_reward": 35
      },
      {
        "id": "L13_Q3",
        "order": 3,
        "title": "Double In Place",
        "description": "Double the value at ptr and return it.",
        "recommended": false,
        "function_signature": {
          "name": "doubleInPlace",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int doubleInPlace(int *ptr) {\n    // Double the value at ptr and return it\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              7
            ],
            "expected": "14",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              50
            ],
            "expected": "100",
            "sample": false
          }
        ],
        "hints": [
          "Multiply: *ptr = *ptr * 2;",
          "Or use: *ptr *= 2;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L14",
    "title": "The Array Navigator",
    "theme": "L14_forge",
    "concept": "pointer arithmetic",
    "description": "Navigate arrays using pointer arithmetic - the foundation of efficient C programming!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 105,
    "map_file": "maps/L14_forge.json",
    "challenges": [],
    "lesson": {
      "title": "Pointer Arithmetic and Arrays",
      "content": [
        "In C, arrays and pointers are closely related. An array name IS a pointer to its first element.",
        "Adding n to a pointer moves it forward by n elements: *(arr + 2) is the same as arr[2].",
        "Use pointer arithmetic to traverse arrays efficiently in loops."
      ],
      "examples": [
        {
          "code": "int getAt(int *arr, int i) {\n    return *(arr + i);  // or arr[i]\n}",
          "explanation": "Access element at index i using pointer arithmetic."
        },
        {
          "code": "int sum(int *arr, int n) {\n    int total = 0;\n    for(int i = 0; i < n; i++)\n        total += *(arr + i);\n    return total;\n}",
          "explanation": "Sum array elements using pointer arithmetic in a loop."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L14_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L14_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L14_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L14_Q1",
        "order": 1,
        "title": "Navigate to Index",
        "description": "Return the element at index i from the array using pointer arithmetic.",
        "recommended": true,
        "function_signature": {
          "name": "getAt",
          "return_type": "int",
          "parameters": [
            {
              "name": "arr",
              "type": "int*"
            },
            {
              "name": "i",
              "type": "int"
            }
          ]
        },
        "user_template": "int getAt(int *arr, int i) {\n    // Return the element at index i\n    // Use *(arr + i) or arr[i]\n    \n}",
        "test_cases": [
          {
            "input": [
              [
                10,
                20,
                30,
                40,
                50
              ],
              2
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              [
                10,
                20,
                30,
                40,
                50
              ],
              0
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              [
                10,
                20,
                30,
                40,
                50
              ],
              4
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "Use *(arr + i) to access the element",
          "This is equivalent to arr[i]"
        ],
        "xp_reward": 30
      },
      {
        "id": "L14_Q2",
        "order": 2,
        "title": "Sum Array Elements",
        "description": "Sum all n elements of the array using pointer arithmetic.",
        "recommended": false,
        "function_signature": {
          "name": "sumArray",
          "return_type": "int",
          "parameters": [
            {
              "name": "arr",
              "type": "int*"
            },
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int sumArray(int *arr, int n) {\n    // Sum all n elements using pointer arithmetic\n    int sum = 0;\n    \n    return sum;\n}",
        "test_cases": [
          {
            "input": [
              [
                1,
                2,
                3
              ],
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              [
                10,
                20,
                30,
                40
              ],
              4
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              [
                5
              ],
              1
            ],
            "expected": "5",
            "sample": false
          },
          {
            "input": [
              [
                0,
                0,
                0
              ],
              3
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Use a for loop: for(int i = 0; i < n; i++)",
          "Add each element: sum += *(arr + i);"
        ],
        "xp_reward": 35
      },
      {
        "id": "L14_Q3",
        "order": 3,
        "title": "Find Element Index",
        "description": "Find the index of target in the array. Return -1 if not found.",
        "recommended": false,
        "function_signature": {
          "name": "findIndex",
          "return_type": "int",
          "parameters": [
            {
              "name": "arr",
              "type": "int*"
            },
            {
              "name": "n",
              "type": "int"
            },
            {
              "name": "target",
              "type": "int"
            }
          ]
        },
        "user_template": "int findIndex(int *arr, int n, int target) {\n    // Find target in arr and return its index\n    // Return -1 if not found\n    \n}",
        "test_cases": [
          {
            "input": [
              [
                5,
                10,
                15,
                20
              ],
              4,
              15
            ],
            "expected": "2",
            "sample": true
          },
          {
            "input": [
              [
                5,
                10,
                15,
                20
              ],
              4,
              5
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              [
                5,
                10,
                15,
                20
              ],
              4,
              99
            ],
            "expected": "-1",
            "sample": false
          },
          {
            "input": [
              [
                42
              ],
              1,
              42
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Loop through the array comparing each element",
          "if (*(arr + i) == target) return i;",
          "Return -1 after the loop if not found"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L15",
    "title": "The Null Trap",
    "theme": "L15_lair",
    "concept": "null pointers",
    "description": "Learn to safely handle null pointers and avoid the dreaded SEGFAULT!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L15_lair.json",
    "challenges": [],
    "lesson": {
      "title": "Null Pointer Safety",
      "content": [
        "NULL is a special pointer value meaning 'points to nothing'. Dereferencing NULL causes SEGMENTATION FAULT (crash)!",
        "Where NULL comes from: malloc fails, you set ptr = NULL explicitly, or pointers are uninitialized.",
        "ALWAYS check for NULL before dereferencing: if (ptr != NULL) { use *ptr }",
        "Defensive programming: anticipate failure cases and handle them gracefully with NULL checks."
      ],
      "examples": [
        {
          "code": "int safeRead(int *ptr) {\n    if (ptr == NULL) return -1;\n    return *ptr;\n}",
          "explanation": "Returns -1 for NULL, otherwise the actual value."
        },
        {
          "code": "int isValid(int *ptr) {\n    return ptr != NULL;\n}",
          "explanation": "Returns 1 if pointer is valid, 0 if NULL."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L15_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L15_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L15_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L15_Q1",
        "order": 1,
        "title": "Safe Read",
        "description": "Return the value at ptr, or -1 if ptr is NULL.",
        "recommended": true,
        "function_signature": {
          "name": "safeRead",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int safeRead(int *ptr) {\n    // Return *ptr if valid, or -1 if NULL\n    \n}",
        "test_cases": [
          {
            "input": [
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              100
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              "NULL"
            ],
            "expected": "-1",
            "sample": false
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Check: if (ptr == NULL) return -1;",
          "Otherwise: return *ptr;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L15_Q2",
        "order": 2,
        "title": "Is Valid Pointer",
        "description": "Return 1 if the pointer is valid (not NULL), 0 if NULL.",
        "recommended": false,
        "function_signature": {
          "name": "isValid",
          "return_type": "int",
          "parameters": [
            {
              "name": "ptr",
              "type": "int*"
            }
          ]
        },
        "user_template": "int isValid(int *ptr) {\n    // Return 1 if ptr is not NULL, 0 if NULL\n    \n}",
        "test_cases": [
          {
            "input": [
              42
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              "NULL"
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "1",
            "sample": false
          }
        ],
        "hints": [
          "Compare ptr to NULL",
          "return ptr != NULL;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L15_Q3",
        "order": 3,
        "title": "Safe Add",
        "description": "Return *a + *b if both pointers are valid. Return 0 if either is NULL.",
        "recommended": false,
        "function_signature": {
          "name": "safeAdd",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int*"
            },
            {
              "name": "b",
              "type": "int*"
            }
          ]
        },
        "user_template": "int safeAdd(int *a, int *b) {\n    // Return *a + *b if both valid, 0 if either is NULL\n    \n}",
        "test_cases": [
          {
            "input": [
              3,
              4
            ],
            "expected": "7",
            "sample": true
          },
          {
            "input": [
              10,
              20
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              "NULL",
              5
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              5,
              "NULL"
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Check both: if (a == NULL || b == NULL)",
          "Return 0 for invalid, *a + *b for valid"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L16",
    "title": "The Blueprint Scroll",
    "theme": "L16_courtyard",
    "concept": "struct definition",
    "description": "Learn to group related data together using structs!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 95,
    "map_file": "maps/L16_courtyard.json",
    "challenges": [],
    "lesson": {
      "title": "Structs: Custom Data Types",
      "content": [
        "A struct groups related variables together into a single unit.",
        "Define with: struct Name { type field; };",
        "Create: struct Name variable;",
        "Access members with dot notation: variable.field"
      ],
      "examples": [
        {
          "code": "struct Hero {\n    int hp;\n    int level;\n};\n\nstruct Hero h;\nh.hp = 100;\nh.level = 5;",
          "explanation": "Define struct, create variable, and set fields using dot notation."
        },
        {
          "code": "int getHP(int hp_val, int level_val) {\n    struct Hero h;\n    h.hp = hp_val;\n    h.level = level_val;\n    return h.hp;\n}",
          "explanation": "Create struct inside function and access its members."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L16_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L16_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L16_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L16_Q1",
        "order": 1,
        "title": "Get Hero HP",
        "description": "Create a Hero struct, populate it, and return its hp field.",
        "recommended": true,
        "function_signature": {
          "name": "getHP",
          "return_type": "int",
          "parameters": [
            {
              "name": "hp_val",
              "type": "int"
            },
            {
              "name": "level_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Hero {\n    int hp;\n    int level;\n};\n\nint getHP(int hp_val, int level_val) {\n    // Create a Hero struct and return its hp field\n    // 1. Declare: struct Hero h;\n    // 2. Set fields: h.hp = hp_val; h.level = level_val;\n    // 3. Return: return h.hp;\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              5
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              50,
              10
            ],
            "expected": "50",
            "sample": true
          },
          {
            "input": [
              0,
              1
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Define struct Hero { int hp; int level; };",
          "Create variable: struct Hero h;",
          "Set fields: h.hp = hp_val; h.level = level_val;",
          "Access member: return h.hp;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L16_Q2",
        "order": 2,
        "title": "Is Hero Alive",
        "description": "Create a Hero struct and return 1 if its hp > 0, else 0.",
        "recommended": false,
        "function_signature": {
          "name": "isAlive",
          "return_type": "int",
          "parameters": [
            {
              "name": "hp_val",
              "type": "int"
            },
            {
              "name": "level_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Hero {\n    int hp;\n    int level;\n};\n\nint isAlive(int hp_val, int level_val) {\n    // Create Hero struct with given values\n    // Return 1 if h.hp > 0, else 0\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              5
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              0,
              1
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              1,
              10
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              -5,
              1
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Create struct Hero h and populate it",
          "Check h.hp > 0",
          "return h.hp > 0;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L16_Q3",
        "order": 3,
        "title": "Calculate Power Level",
        "description": "Create a Hero struct and compute its power: hp + (level \u00d7 10).",
        "recommended": false,
        "function_signature": {
          "name": "powerLevel",
          "return_type": "int",
          "parameters": [
            {
              "name": "hp_val",
              "type": "int"
            },
            {
              "name": "level_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Hero {\n    int hp;\n    int level;\n};\n\nint powerLevel(int hp_val, int level_val) {\n    // Create Hero struct with given values\n    // Return h.hp + h.level * 10\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              5
            ],
            "expected": "150",
            "sample": true
          },
          {
            "input": [
              50,
              10
            ],
            "expected": "150",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              200,
              20
            ],
            "expected": "400",
            "sample": false
          }
        ],
        "hints": [
          "Create struct Hero h and populate it",
          "Access both fields: h.hp and h.level",
          "return h.hp + h.level * 10;"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L17",
    "title": "The Chest Contents",
    "theme": "L17_throne",
    "concept": "struct members",
    "description": "Access and compute with struct member values!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L17_throne.json",
    "challenges": [],
    "lesson": {
      "title": "Working with Struct Members",
      "content": [
        "Use dot notation to access struct members: chest.gold",
        "Create struct variables and populate their fields",
        "Members can be read, modified, and used in calculations",
        "Each field acts like a regular variable of its type"
      ],
      "examples": [
        {
          "code": "struct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nstruct Chest c;\nc.gold = 100;\nc.gems = 50;\nc.keys = 3;",
          "explanation": "Define struct, create variable, and populate fields."
        },
        {
          "code": "int getGold(int gold_val, int gems_val, int keys_val) {\n    struct Chest c;\n    c.gold = gold_val;\n    c.gems = gems_val;\n    c.keys = keys_val;\n    return c.gold;\n}",
          "explanation": "Create and access struct members using dot notation."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L17_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L17_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L17_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L17_Q1",
        "order": 1,
        "title": "Get Gold Count",
        "description": "Create a Chest struct, populate it, and return the gold field.",
        "recommended": true,
        "function_signature": {
          "name": "getGold",
          "return_type": "int",
          "parameters": [
            {
              "name": "gold_val",
              "type": "int"
            },
            {
              "name": "gems_val",
              "type": "int"
            },
            {
              "name": "keys_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint getGold(int gold_val, int gems_val, int keys_val) {\n    // Create a Chest struct and return its gold field\n    // struct Chest c;\n    // c.gold = gold_val; c.gems = gems_val; c.keys = keys_val;\n    // return c.gold;\n    \n}",
        "test_cases": [
          {
            "input": [
              500,
              10,
              3
            ],
            "expected": "500",
            "sample": true
          },
          {
            "input": [
              100,
              5,
              2
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Define struct Chest { int gold; int gems; int keys; };",
          "Create variable: struct Chest c;",
          "Set all fields: c.gold = gold_val; etc.",
          "return c.gold;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L17_Q2",
        "order": 2,
        "title": "Total Chest Value",
        "description": "Create a Chest struct, populate it, and compute the total value.",
        "recommended": false,
        "function_signature": {
          "name": "totalValue",
          "return_type": "int",
          "parameters": [
            {
              "name": "gold_val",
              "type": "int"
            },
            {
              "name": "gems_val",
              "type": "int"
            },
            {
              "name": "keys_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint totalValue(int gold_val, int gems_val, int keys_val) {\n    // Create Chest struct with given values\n    // Return c.gold + c.gems*10 + c.keys*5\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              5,
              2
            ],
            "expected": "160",
            "sample": true
          },
          {
            "input": [
              500,
              10,
              3
            ],
            "expected": "615",
            "sample": true
          },
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              0,
              10,
              10
            ],
            "expected": "150",
            "sample": false
          }
        ],
        "hints": [
          "Create and populate struct Chest c",
          "Access all fields: c.gold, c.gems, c.keys",
          "return c.gold + c.gems * 10 + c.keys * 5;"
        ],
        "xp_reward": 35
      },
      {
        "id": "L17_Q3",
        "order": 3,
        "title": "Is Chest Empty",
        "description": "Create a Chest struct, populate it, and return 1 if all fields are 0.",
        "recommended": false,
        "function_signature": {
          "name": "isEmpty",
          "return_type": "int",
          "parameters": [
            {
              "name": "gold_val",
              "type": "int"
            },
            {
              "name": "gems_val",
              "type": "int"
            },
            {
              "name": "keys_val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint isEmpty(int gold_val, int gems_val, int keys_val) {\n    // Create Chest struct with given values\n    // Return 1 if all fields are 0, else 0\n    \n}",
        "test_cases": [
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              1,
              0,
              0
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              0,
              1,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              50,
              10
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Create and populate struct Chest c",
          "Check: c.gold == 0 && c.gems == 0 && c.keys == 0",
          "Use && to combine conditions"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L18",
    "title": "The Teleport Chest",
    "theme": "L18_treasury",
    "concept": "struct pointers",
    "description": "Modify struct values through pointers using the arrow operator!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 95,
    "map_file": "maps/L18_treasury.json",
    "challenges": [],
    "lesson": {
      "title": "Struct Pointers and Arrow Operator",
      "content": [
        "When you have a pointer to a struct, use -> to access members",
        "ptr->field is shorthand for (*ptr).field",
        "This lets functions modify struct data in the caller's scope"
      ],
      "examples": [
        {
          "code": "struct Chest { int gold; int gems; };\n\nint addGold(int gold, int amt) {\n    struct Chest c;\n    c.gold = gold;\n    struct Chest *ptr = &c;\n    ptr->gold += amt;\n    return ptr->gold;\n}",
          "explanation": "Create a struct, get pointer to it, use -> to modify its members."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L18_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L18_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L18_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L18_Q1",
        "order": 1,
        "title": "Add Gold via Arrow",
        "description": "Create a Chest struct, use a pointer with -> to add gold, return the new total.",
        "recommended": true,
        "function_signature": {
          "name": "addGold",
          "return_type": "int",
          "parameters": [
            {
              "name": "currentGold",
              "type": "int"
            },
            {
              "name": "addAmount",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n};\n\nint addGold(int currentGold, int addAmount) {\n    // 1. Create a struct Chest and set gold = currentGold\n    // 2. Create a pointer to it: struct Chest *ptr = &c;\n    // 3. Use ptr->gold to add addAmount\n    // 4. Return ptr->gold\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              50
            ],
            "expected": "150",
            "sample": true
          },
          {
            "input": [
              0,
              25
            ],
            "expected": "25",
            "sample": true
          },
          {
            "input": [
              200,
              0
            ],
            "expected": "200",
            "sample": false
          }
        ],
        "hints": [
          "struct Chest c; c.gold = currentGold;",
          "struct Chest *ptr = &c;",
          "ptr->gold += addAmount; return ptr->gold;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L18_Q2",
        "order": 2,
        "title": "Modify Two Fields",
        "description": "Use arrow operator to set both gold and gems, then return their sum.",
        "recommended": false,
        "function_signature": {
          "name": "setTreasure",
          "return_type": "int",
          "parameters": [
            {
              "name": "goldAmt",
              "type": "int"
            },
            {
              "name": "gemAmt",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n};\n\nint setTreasure(int goldAmt, int gemAmt) {\n    // Create Chest, get pointer, use -> to set both fields\n    // Return ptr->gold + ptr->gems\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              50
            ],
            "expected": "150",
            "sample": true
          },
          {
            "input": [
              25,
              25
            ],
            "expected": "50",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Create struct and pointer as before",
          "ptr->gold = goldAmt; ptr->gems = gemAmt;",
          "Return the sum using ptr-> for both"
        ],
        "xp_reward": 30
      },
      {
        "id": "L18_Q3",
        "order": 3,
        "title": "Upgrade Chest",
        "description": "Double the gold value through pointer, add bonus gems, return new gold.",
        "recommended": false,
        "function_signature": {
          "name": "upgradeChest",
          "return_type": "int",
          "parameters": [
            {
              "name": "initialGold",
              "type": "int"
            },
            {
              "name": "bonusGems",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Chest {\n    int gold;\n    int gems;\n};\n\nint upgradeChest(int initialGold, int bonusGems) {\n    // Create Chest with gold = initialGold\n    // Use ptr-> to double gold and add bonusGems to gems\n    // Return ptr->gold\n    \n}",
        "test_cases": [
          {
            "input": [
              50,
              10
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              25,
              5
            ],
            "expected": "50",
            "sample": true
          },
          {
            "input": [
              0,
              100
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "ptr->gold *= 2; to double it",
          "ptr->gems = bonusGems;",
          "Arrow operator works for both reading and writing"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L19",
    "title": "The Guild Hierarchy",
    "theme": "L19_dungeon",
    "concept": "nested structs",
    "description": "Work with structs that contain other structs - hierarchical data!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 65,
    "map_file": "maps/L19_dungeon.json",
    "challenges": [],
    "lesson": {
      "title": "Nested Structs",
      "content": [
        "Structs can contain other structs, creating hierarchical data",
        "Access nested fields with chained dots: guild.leader.level",
        "Initialize with nested braces: struct Guild g = {{100, 5}, 10};"
      ],
      "examples": [
        {
          "code": "struct Hero { int hp; int level; };\nstruct Guild { struct Hero leader; int memberCount; };\n\nint guildPower(int leaderHp, int leaderLvl, int members) {\n    struct Hero h = {leaderHp, leaderLvl};\n    struct Guild g = {h, members};\n    return g.leader.level * g.memberCount;\n}",
          "explanation": "Create nested structs and access members with chained dot notation."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L19_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L19_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L19_Q1",
        "order": 1,
        "title": "Access Nested Level",
        "description": "Create nested Hero/Guild structs, return the leader's level using chained dots.",
        "recommended": true,
        "function_signature": {
          "name": "leaderLevel",
          "return_type": "int",
          "parameters": [
            {
              "name": "leaderHp",
              "type": "int"
            },
            {
              "name": "leaderLvl",
              "type": "int"
            },
            {
              "name": "members",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Hero {\n    int hp;\n    int level;\n};\n\nstruct Guild {\n    struct Hero leader;\n    int memberCount;\n};\n\nint leaderLevel(int leaderHp, int leaderLvl, int members) {\n    // 1. Create a Hero: struct Hero h = {leaderHp, leaderLvl};\n    // 2. Create a Guild: struct Guild g; g.leader = h; g.memberCount = members;\n    // 3. Return g.leader.level using chained dot notation\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              50,
              100
            ],
            "expected": "50",
            "sample": true
          },
          {
            "input": [
              50,
              10,
              50
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              1,
              1,
              1
            ],
            "expected": "1",
            "sample": false
          }
        ],
        "hints": [
          "Create Hero first, then assign to Guild's leader field",
          "Access nested: g.leader.level",
          "Chained dots for nested struct access"
        ],
        "xp_reward": 30
      },
      {
        "id": "L19_Q2",
        "order": 2,
        "title": "Calculate Guild Power",
        "description": "Use nested structs to compute power: leader.level \u00d7 memberCount.",
        "recommended": false,
        "function_signature": {
          "name": "guildPower",
          "return_type": "int",
          "parameters": [
            {
              "name": "leaderHp",
              "type": "int"
            },
            {
              "name": "leaderLvl",
              "type": "int"
            },
            {
              "name": "memberCount",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Hero {\n    int hp;\n    int level;\n};\n\nstruct Guild {\n    struct Hero leader;\n    int memberCount;\n};\n\nint guildPower(int leaderHp, int leaderLvl, int memberCount) {\n    // Create Hero and Guild using struct initialization\n    // Return g.leader.level * g.memberCount\n    \n}",
        "test_cases": [
          {
            "input": [
              100,
              50,
              100
            ],
            "expected": "5000",
            "sample": true
          },
          {
            "input": [
              50,
              10,
              50
            ],
            "expected": "500",
            "sample": true
          },
          {
            "input": [
              1,
              1,
              1
            ],
            "expected": "1",
            "sample": false
          },
          {
            "input": [
              0,
              0,
              100
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "struct Hero h = {leaderHp, leaderLvl};",
          "struct Guild g = {h, memberCount};",
          "Multiply g.leader.level * g.memberCount"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L20",
    "title": "The Army Roster",
    "theme": "L20_passage",
    "concept": "array of structs",
    "description": "Process arrays of structured data - the foundation of real programs!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L20_passage.json",
    "challenges": [],
    "lesson": {
      "title": "Arrays of Structs",
      "content": [
        "Arrays can hold structs just like they hold integers",
        "Access with: array[i].field (combines array indexing and struct access)",
        "Loop through to process all elements: for(int i = 0; i < n; i++)"
      ],
      "examples": [
        {
          "code": "struct Soldier { int strength; };\n\nint totalStrength(int s1, int s2, int s3) {\n    struct Soldier army[3];\n    army[0].strength = s1;\n    army[1].strength = s2;\n    army[2].strength = s3;\n    int sum = 0;\n    for(int i = 0; i < 3; i++) sum += army[i].strength;\n    return sum;\n}",
          "explanation": "Create array of structs, populate, then iterate with array[i].field syntax."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L20_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L20_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L20_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L20_Q1",
        "order": 1,
        "title": "Sum Army Strength",
        "description": "Create array of Soldier structs, populate from parameters, sum using loop.",
        "recommended": true,
        "function_signature": {
          "name": "totalStrength",
          "return_type": "int",
          "parameters": [
            {
              "name": "s1",
              "type": "int"
            },
            {
              "name": "s2",
              "type": "int"
            },
            {
              "name": "s3",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Soldier {\n    int strength;\n};\n\nint totalStrength(int s1, int s2, int s3) {\n    // 1. Create array: struct Soldier army[3];\n    // 2. Set values: army[0].strength = s1; etc.\n    // 3. Loop and sum: sum += army[i].strength;\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              25,
              50
            ],
            "expected": "85",
            "sample": true
          },
          {
            "input": [
              5,
              5,
              5
            ],
            "expected": "15",
            "sample": true
          },
          {
            "input": [
              100,
              0,
              0
            ],
            "expected": "100",
            "sample": false
          }
        ],
        "hints": [
          "struct Soldier army[3]; declares array of 3 Soldiers",
          "army[0].strength = s1; to populate",
          "Loop: for(int i = 0; i < 3; i++) sum += army[i].strength;"
        ],
        "xp_reward": 35
      },
      {
        "id": "L20_Q2",
        "order": 2,
        "title": "Find Strongest Soldier",
        "description": "Create soldier array, find index with maximum strength.",
        "recommended": false,
        "function_signature": {
          "name": "strongestIndex",
          "return_type": "int",
          "parameters": [
            {
              "name": "s1",
              "type": "int"
            },
            {
              "name": "s2",
              "type": "int"
            },
            {
              "name": "s3",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Soldier {\n    int strength;\n};\n\nint strongestIndex(int s1, int s2, int s3) {\n    // Create array, populate, find index with max strength\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              50,
              25
            ],
            "expected": "1",
            "sample": true
          },
          {
            "input": [
              100,
              50,
              25
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              10,
              25,
              50
            ],
            "expected": "2",
            "sample": false
          }
        ],
        "hints": [
          "Track maxIdx starting at 0",
          "Compare: if(army[i].strength > army[maxIdx].strength)",
          "Update maxIdx when you find larger value"
        ],
        "xp_reward": 35
      },
      {
        "id": "L20_Q3",
        "order": 3,
        "title": "Count Elite Soldiers",
        "description": "Count soldiers with strength >= threshold using array iteration.",
        "recommended": false,
        "function_signature": {
          "name": "countElite",
          "return_type": "int",
          "parameters": [
            {
              "name": "s1",
              "type": "int"
            },
            {
              "name": "s2",
              "type": "int"
            },
            {
              "name": "s3",
              "type": "int"
            },
            {
              "name": "threshold",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Soldier {\n    int strength;\n};\n\nint countElite(int s1, int s2, int s3, int threshold) {\n    // Create array, populate, count how many meet threshold\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              25,
              50,
              20
            ],
            "expected": "2",
            "sample": true
          },
          {
            "input": [
              10,
              25,
              50,
              100
            ],
            "expected": "0",
            "sample": true
          },
          {
            "input": [
              10,
              25,
              50,
              10
            ],
            "expected": "3",
            "sample": false
          },
          {
            "input": [
              5,
              15,
              25,
              15
            ],
            "expected": "2",
            "sample": false
          }
        ],
        "hints": [
          "Initialize count = 0",
          "Loop: if(army[i].strength >= threshold) count++;",
          "Combine array access with struct member access"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L21",
    "title": "Summon Land",
    "theme": "L21_stairs",
    "concept": "malloc basics",
    "description": "The void stretches before you. Use malloc to summon solid ground from nothingness!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L21_stairs.json",
    "challenges": [],
    "lesson": {
      "title": "Dynamic Memory with Malloc",
      "content": [
        "malloc (memory allocate) requests memory from the system at runtime.",
        "CRITICAL: malloc can fail and return NULL if memory is exhausted!",
        "ALWAYS check: int *ptr = malloc(...); if (ptr == NULL) { handle error }",
        "Always free() when done to prevent memory leaks."
      ],
      "examples": [
        {
          "code": "int mallocRead(int val) {\n    int *p = (int*)malloc(sizeof(int));\n    if (p == NULL) return -1;  // Handle failure!\n    *p = val;\n    int result = *p;\n    free(p);\n    return result;\n}",
          "explanation": "Safe malloc pattern: allocate, check NULL, use, free."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L21_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L21_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L21_Q1",
        "order": 1,
        "title": "Allocate and Read",
        "description": "Malloc an integer, store the given value, read it back, free, and return.",
        "recommended": true,
        "function_signature": {
          "name": "mallocRead",
          "return_type": "int",
          "parameters": [
            {
              "name": "val",
              "type": "int"
            }
          ]
        },
        "user_template": "int mallocRead(int val) {\n    // 1. Allocate memory for one int\n    // 2. CHECK IF NULL - return -1 if allocation failed!\n    // 3. Store val in it\n    // 4. Read the value back\n    // 5. Free the memory\n    // 6. Return the value\n    \n}",
        "test_cases": [
          {
            "input": [
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              100
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              -5
            ],
            "expected": "-5",
            "sample": false
          }
        ],
        "hints": [
          "SAFETY: Check if malloc returns NULL!",
          "int *p = (int*)malloc(sizeof(int));",
          "*p = val; to store the value",
          "Don't forget to free(p) before returning!"
        ],
        "xp_reward": 30
      },
      {
        "id": "L21_Q2",
        "order": 2,
        "title": "Allocate and Compute",
        "description": "Malloc an integer, compute a + b, store it, read back, free, and return.",
        "recommended": false,
        "function_signature": {
          "name": "mallocSum",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            }
          ]
        },
        "user_template": "int mallocSum(int a, int b) {\n    // Allocate, compute a+b, store, read, free, return\n    \n}",
        "test_cases": [
          {
            "input": [
              3,
              4
            ],
            "expected": "7",
            "sample": true
          },
          {
            "input": [
              10,
              20
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              -50
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "Compute a + b and store in allocated memory",
          "int *p = (int*)malloc(sizeof(int)); *p = a + b;",
          "Read back with int result = *p; before freeing"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L22",
    "title": "The Banish Spell",
    "theme": "L22_alchemy",
    "concept": "free memory",
    "description": "What you summon, you must also banish! Release the memory back to the void.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L22_alchemy.json",
    "challenges": [],
    "lesson": {
      "title": "Releasing Memory with Free",
      "content": [
        "Every malloc must have a matching free, or you create a memory leak.",
        "DANGER: After free(ptr), the pointer is 'dangling' - using it crashes!",
        "Safe pattern: save result before freeing, then return the saved value.",
        "Never return a freed pointer - it points to released memory!"
      ],
      "examples": [
        {
          "code": "int computeAndFree(int a, int b) {\n    int *p = (int*)malloc(sizeof(int));\n    if (p == NULL) return -1;\n    *p = a * b;\n    int result = *p;\n    free(p);  // Pointer now dangling!\n    return result;  // Safe: returning the value, not the pointer\n}",
          "explanation": "Allocate, compute, save result, free, then return the saved result."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L22_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L22_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L22_Q1",
        "order": 1,
        "title": "Square and Free",
        "description": "Allocate memory, compute n squared, save result, free memory, return result.",
        "recommended": true,
        "function_signature": {
          "name": "squareAndFree",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int squareAndFree(int n) {\n    // 1. Allocate an int\n    // 2. Compute n * n and store it\n    // 3. Save the result to a local variable\n    // 4. Free the memory\n    // 5. Return the saved result\n    \n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "25",
            "sample": true
          },
          {
            "input": [
              3
            ],
            "expected": "9",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              10
            ],
            "expected": "100",
            "sample": false
          }
        ],
        "hints": [
          "Save result before freeing: int result = *p;",
          "Then free(p); and return result;",
          "Never return a freed pointer!",
          "WARNING: After free(p), never use *p again! Save result first: int result = *p; free(p); return result;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L22_Q2",
        "order": 2,
        "title": "Double Allocation",
        "description": "Allocate TWO integers, store a and b, compute sum, free both, return sum.",
        "recommended": false,
        "function_signature": {
          "name": "allocTwoSum",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            }
          ]
        },
        "user_template": "int allocTwoSum(int a, int b) {\n    // Allocate two ints, store a and b, sum them\n    // Free both allocations, return the sum\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              20
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              -50
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "int *p1 = malloc(...); int *p2 = malloc(...);",
          "Compute sum: int sum = *p1 + *p2;",
          "Free both: free(p1); free(p2);"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L23",
    "title": "The Cursed Hoarding",
    "theme": "L23_observatory",
    "concept": "memory leaks",
    "description": "A curse afflicts those who hoard without releasing! Learn proper cleanup patterns.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L23_observatory.json",
    "challenges": [],
    "lesson": {
      "title": "Avoiding Memory Leaks",
      "content": [
        "A memory leak is allocated memory that's never freed - lost forever!",
        "In the game world, leaks spawn void creatures that consume your realm.",
        "In loops: free each allocation before the next iteration.",
        "In branches: ensure ALL code paths call free before returning."
      ],
      "examples": [
        {
          "code": "int loopNoLeak(int n) {\n    int sum = 0;\n    for(int i = 0; i < n; i++) {\n        int *p = malloc(sizeof(int));\n        *p = i;\n        sum += *p;\n        free(p);  // Free each iteration!\n    }\n    return sum;\n}",
          "explanation": "Each allocation is freed within its iteration - no leaks. If free() were outside the loop, all but the last allocation would leak!"
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L23_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L23_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L23_Q1",
        "order": 1,
        "title": "Loop Cleanup",
        "description": "Sum values 0 to n-1 using malloc in a loop. Free properly each iteration!",
        "recommended": true,
        "function_signature": {
          "name": "loopSum",
          "return_type": "int",
          "parameters": [
            {
              "name": "n",
              "type": "int"
            }
          ]
        },
        "user_template": "int loopSum(int n) {\n    int sum = 0;\n    for(int i = 0; i < n; i++) {\n        // Allocate, add i to sum, free\n        \n    }\n    return sum;\n}",
        "test_cases": [
          {
            "input": [
              5
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              3
            ],
            "expected": "3",
            "sample": true
          },
          {
            "input": [
              1
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              10
            ],
            "expected": "45",
            "sample": false
          }
        ],
        "hints": [
          "SAFETY: Every malloc inside a loop must have a matching free inside that same loop!",
          "int *p = malloc(sizeof(int)); *p = i;",
          "sum += *p; then free(p);",
          "Free inside the loop, not after!"
        ],
        "xp_reward": 30
      },
      {
        "id": "L23_Q2",
        "order": 2,
        "title": "Branch Cleanup",
        "description": "Allocate memory, return different values based on condition, but always free!",
        "recommended": false,
        "function_signature": {
          "name": "branchClean",
          "return_type": "int",
          "parameters": [
            {
              "name": "val",
              "type": "int"
            },
            {
              "name": "flag",
              "type": "int"
            }
          ]
        },
        "user_template": "int branchClean(int val, int flag) {\n    int *p = (int*)malloc(sizeof(int));\n    *p = val;\n    // If flag != 0, return *p doubled\n    // Otherwise return *p as-is\n    // IMPORTANT: Free memory on ALL paths!\n    \n}",
        "test_cases": [
          {
            "input": [
              5,
              1
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              5,
              0
            ],
            "expected": "5",
            "sample": true
          },
          {
            "input": [
              10,
              1
            ],
            "expected": "20",
            "sample": false
          },
          {
            "input": [
              10,
              0
            ],
            "expected": "10",
            "sample": false
          }
        ],
        "hints": [
          "SAFETY: Test BOTH paths (flag=0 and flag=1) to ensure proper cleanup!",
          "Save result before freeing: int result = ...;",
          "free(p); must happen before EVERY return",
          "Or: compute result first, free, then return"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L24",
    "title": "The Expanding Army",
    "theme": "L24_portal",
    "concept": "dynamic arrays",
    "description": "Your army grows! Use realloc to expand arrays when needed.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 75,
    "map_file": "maps/L24_portal.json",
    "challenges": [],
    "lesson": {
      "title": "Growing Arrays with Realloc",
      "content": [
        "realloc resizes allocated memory, preserving existing data.",
        "DANGER: realloc can fail and return NULL, losing your original pointer!",
        "SAFE PATTERN: int *temp = realloc(arr, newSize); if(temp) arr = temp;",
        "Always check realloc result before assigning back to original pointer."
      ],
      "examples": [
        {
          "code": "int *arr = malloc(sizeof(int));\narr[0] = 10;\nint *temp = realloc(arr, 2 * sizeof(int));\nif (temp == NULL) { free(arr); return -1; }\narr = temp;\narr[1] = 20;",
          "explanation": "Safe realloc: save to temp, check NULL, then assign back."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 224,
          "y": 224,
          "quest_id": "L24_Q1"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L24_Q2"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L24_Q1",
        "order": 1,
        "title": "Grow and Sum",
        "description": "Malloc for 1 int, store a, realloc to 2 ints, store b, return sum.",
        "recommended": true,
        "function_signature": {
          "name": "growSum",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            }
          ]
        },
        "user_template": "int growSum(int a, int b) {\n    // 1. Malloc space for 1 int, store a\n    // 2. Realloc to 2 ints - USE TEMP POINTER!\n    // 3. Check if realloc succeeded before using\n    // 4. Store b in [1], sum, free, return\n    \n}",
        "test_cases": [
          {
            "input": [
              10,
              20
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              5,
              5
            ],
            "expected": "10",
            "sample": true
          },
          {
            "input": [
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              -50
            ],
            "expected": "50",
            "sample": false
          }
        ],
        "hints": [
          "SAFE realloc: int *temp = realloc(arr, size); if(temp) arr = temp;",
          "int *arr = malloc(sizeof(int)); arr[0] = a;",
          "int *temp = realloc(arr, 2 * sizeof(int)); if (temp) arr = temp; arr[1] = b;",
          "Don't forget to free(arr) before returning!"
        ],
        "xp_reward": 35
      },
      {
        "id": "L24_Q2",
        "order": 2,
        "title": "Triple Grow",
        "description": "Start with malloc(1), realloc twice to reach size 3, store a,b,c, return sum.",
        "recommended": false,
        "function_signature": {
          "name": "tripleGrow",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "user_template": "int tripleGrow(int a, int b, int c) {\n    // Malloc(1), store a\n    // Realloc(2), store b\n    // Realloc(3), store c\n    // Sum all three, free, return\n    \n}",
        "test_cases": [
          {
            "input": [
              1,
              2,
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              10,
              20,
              30
            ],
            "expected": "60",
            "sample": true
          },
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              100,
              200,
              300
            ],
            "expected": "600",
            "sample": false
          }
        ],
        "hints": [
          "Each realloc grows by one element",
          "arr = realloc(arr, 2*sizeof(int)); then arr = realloc(arr, 3*sizeof(int));",
          "Sum: arr[0] + arr[1] + arr[2]"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L25",
    "title": "Chain of Portals",
    "theme": "L25_sanctum",
    "concept": "linked lists",
    "description": "Create chains of nodes that point to each other - the foundation of linked lists!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int value;\n    struct Node *next;\n};\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L25_sanctum.json",
    "challenges": [],
    "lesson": {
      "title": "Linked Lists",
      "content": [
        "A linked list is a chain of nodes, each containing data and a pointer to the next node.",
        "struct Node { int value; struct Node *next; }; defines a self-referential struct.",
        "Traverse by following next pointers until you hit NULL (end of list)."
      ],
      "examples": [
        {
          "code": "int countNodes(struct Node *head) {\n    int count = 0;\n    struct Node *curr = head;\n    while(curr != NULL) {\n        count++;\n        curr = curr->next;\n    }\n    return count;\n}",
          "explanation": "Traverse from head to end, counting nodes."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {
          "x": 160,
          "y": 224,
          "quest_id": "L25_Q1"
        },
        {
          "x": 288,
          "y": 224,
          "quest_id": "L25_Q2"
        },
        {
          "x": 416,
          "y": 224,
          "quest_id": "L25_Q3"
        }
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L25_Q1",
        "order": 1,
        "title": "Create a Node",
        "description": "Allocate a Node, set its value, set next to NULL, return the value.",
        "recommended": true,
        "function_signature": {
          "name": "createNode",
          "return_type": "int",
          "parameters": [
            {
              "name": "val",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint createNode(int val) {\n    // Allocate a Node, set value=val, next=NULL\n    // Return the stored value, then free\n    \n}",
        "test_cases": [
          {
            "input": [
              42
            ],
            "expected": "42",
            "sample": true
          },
          {
            "input": [
              100
            ],
            "expected": "100",
            "sample": true
          },
          {
            "input": [
              0
            ],
            "expected": "0",
            "sample": false
          },
          {
            "input": [
              -5
            ],
            "expected": "-5",
            "sample": false
          }
        ],
        "hints": [
          "struct Node *n = malloc(sizeof(struct Node));",
          "n->value = val; n->next = NULL;",
          "int result = n->value; free(n); return result;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L25_Q2",
        "order": 2,
        "title": "Sum Node Values",
        "description": "Sum all values by traversing the linked list.",
        "recommended": false,
        "function_signature": {
          "name": "sumList",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint sumList(int a, int b, int c) {\n    // Create list: a -> b -> c -> NULL\n    // Traverse and SUM all values (not count!)\n    // Free all nodes, return sum\n    \n}",
        "test_cases": [
          {
            "input": [
              1,
              2,
              3
            ],
            "expected": "6",
            "sample": true
          },
          {
            "input": [
              10,
              20,
              30
            ],
            "expected": "60",
            "sample": true
          },
          {
            "input": [
              0,
              0,
              0
            ],
            "expected": "0",
            "sample": false
          }
        ],
        "hints": [
          "Create 3 nodes and link them: n1->next = n2; n2->next = n3; n3->next = NULL;",
          "Traverse and sum: while(curr != NULL) { sum += curr->value; curr = curr->next; }",
          "Free all 3 nodes before returning"
        ],
        "xp_reward": 35
      },
      {
        "id": "L25_Q3",
        "order": 3,
        "title": "Last Value",
        "description": "Create a 3-node list (a->b->c), traverse to find the last value, return it.",
        "recommended": false,
        "function_signature": {
          "name": "lastValue",
          "return_type": "int",
          "parameters": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            },
            {
              "name": "c",
              "type": "int"
            }
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint lastValue(int a, int b, int c) {\n    // Create list: a -> b -> c -> NULL\n    // Traverse to find last node (where next == NULL)\n    // Return its value, free all nodes\n    \n}",
        "test_cases": [
          {
            "input": [
              1,
              2,
              3
            ],
            "expected": "3",
            "sample": true
          },
          {
            "input": [
              10,
              20,
              30
            ],
            "expected": "30",
            "sample": true
          },
          {
            "input": [
              100,
              200,
              300
            ],
            "expected": "300",
            "sample": false
          },
          {
            "input": [
              5,
              5,
              5
            ],
            "expected": "5",
            "sample": false
          }
        ],
        "hints": [
          "Traverse: while(curr->next != NULL) curr = curr->next;",
          "When curr->next is NULL, curr is the last node",
          "Return curr->value after saving it, then free all nodes"
        ],
        "xp_reward": 45
      }
    ]
  }
]