[
  {
    "id": "L01",
    "title": "The First Spell",
    "theme": "L01_village",
    "concept": "return values",
    "description": "Master the art of returning values to unlock the door ahead. Complete all quests to proceed.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    // Tests will call your function\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L01_first_spell.json",
    "challenges": [],
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 192, "y": 224, "quest_id": "L01_Q1"},
        {"x": 320, "y": 224, "quest_id": "L01_Q2"},
        {"x": 448, "y": 224, "quest_id": "L01_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L01_Q1",
        "order": 1,
        "title": "The Secret Number",
        "description": "Return the secret number 42 to prove your worth.",
        "recommended": true,
        "function_signature": {
          "name": "getSecret",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getSecret() {\n    // Return the secret number: 42\n    \n}",
        "test_cases": [
          {"input": [], "expected": "42", "sample": true}
        ],
        "hints": [
          "Use the 'return' keyword to send a value back",
          "Example: return 42;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L01_Q2",
        "order": 2,
        "title": "Double Trouble",
        "description": "Return a number that is twice the magic constant (21 * 2).",
        "recommended": false,
        "function_signature": {
          "name": "getDouble",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getDouble() {\n    // Return 21 multiplied by 2\n    \n}",
        "test_cases": [
          {"input": [], "expected": "42", "sample": true}
        ],
        "hints": [
          "You can use arithmetic in return statements",
          "Example: return 5 * 2;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L01_Q3",
        "order": 3,
        "title": "The Sum Spell",
        "description": "Return the sum of three numbers: 10, 20, and 12.",
        "recommended": false,
        "function_signature": {
          "name": "getSum",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int getSum() {\n    // Return 10 + 20 + 12\n    \n}",
        "test_cases": [
          {"input": [], "expected": "42", "sample": true}
        ],
        "hints": [
          "Add numbers with the + operator",
          "Example: return 1 + 2 + 3;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L02",
    "title": "The Empty Backpack",
    "theme": "L02_market",
    "concept": "variables",
    "description": "The merchant needs help with calculations. Master arithmetic with parameters!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L02_empty_backpack.json",
    "challenges": [],
    "lesson": {
      "title": "Variables and Arithmetic",
      "content": [
        "Variables store data that your program can use and modify. In C, you must declare a variable's type before using it.",
        "Function parameters are special variables that receive values when the function is called.",
        "Arithmetic operators like + (add), - (subtract), * (multiply), and / (divide) work with numeric variables."
      ],
      "examples": [
        {
          "code": "int add(int x, int y) {\n    return x + y;\n}",
          "explanation": "Parameters x and y receive values from the caller, and we return their sum."
        },
        {
          "code": "int double(int n) {\n    return n * 2;\n}",
          "explanation": "We can perform arithmetic on parameters and return the result."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L02_Q1"},
        {"x": 288, "y": 224, "quest_id": "L02_Q2"},
        {"x": 416, "y": 224, "quest_id": "L02_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L02_Q1",
        "order": 1,
        "title": "Adding Weights",
        "description": "The merchant needs to calculate the total weight of two items.",
        "recommended": true,
        "function_signature": {
          "name": "addWeight",
          "return_type": "int",
          "parameters": [
            {"name": "item1", "type": "int"},
            {"name": "item2", "type": "int"}
          ]
        },
        "user_template": "int addWeight(int item1, int item2) {\n    // Return the sum of item1 and item2\n    \n}",
        "test_cases": [
          {"input": [10, 25], "expected": "35", "sample": true},
          {"input": [5, 5], "expected": "10", "sample": true},
          {"input": [100, 200], "expected": "300", "sample": false},
          {"input": [0, 42], "expected": "42", "sample": false}
        ],
        "hints": [
          "Use the + operator to add numbers",
          "Return the sum: return item1 + item2;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L02_Q2",
        "order": 2,
        "title": "Calculate Area",
        "description": "Find the area of a rectangular storage crate.",
        "recommended": false,
        "function_signature": {
          "name": "calculateArea",
          "return_type": "int",
          "parameters": [
            {"name": "width", "type": "int"},
            {"name": "height", "type": "int"}
          ]
        },
        "user_template": "int calculateArea(int width, int height) {\n    // Return width multiplied by height\n    \n}",
        "test_cases": [
          {"input": [3, 4], "expected": "12", "sample": true},
          {"input": [5, 5], "expected": "25", "sample": true},
          {"input": [1, 100], "expected": "100", "sample": false},
          {"input": [10, 10], "expected": "100", "sample": false}
        ],
        "hints": [
          "Use the * operator to multiply",
          "Area = width * height"
        ],
        "xp_reward": 30
      },
      {
        "id": "L02_Q3",
        "order": 3,
        "title": "Triple Sum",
        "description": "Sum three item weights for the heavy load calculation.",
        "recommended": false,
        "function_signature": {
          "name": "tripleSum",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"},
            {"name": "c", "type": "int"}
          ]
        },
        "user_template": "int tripleSum(int a, int b, int c) {\n    // Return the sum of all three values\n    \n}",
        "test_cases": [
          {"input": [1, 2, 3], "expected": "6", "sample": true},
          {"input": [10, 20, 30], "expected": "60", "sample": true},
          {"input": [0, 0, 0], "expected": "0", "sample": false},
          {"input": [100, 200, 300], "expected": "600", "sample": false}
        ],
        "hints": [
          "Chain additions: a + b + c",
          "Example: return a + b + c;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L03",
    "title": "The Gatekeeper",
    "theme": "L03_tower",
    "concept": "if/else",
    "description": "The guard tests your logic. Prove your worth with conditional decisions!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L03_gatekeeper.json",
    "challenges": [],
    "lesson": {
      "title": "Conditional Logic with if/else",
      "content": [
        "Programs often need to make decisions. The if/else statement lets your code choose between different paths based on conditions.",
        "A condition is an expression that evaluates to true or false. Comparison operators include: > (greater), < (less), >= (greater or equal), <= (less or equal), == (equal), != (not equal).",
        "The if block runs when the condition is true; the else block runs when it's false."
      ],
      "examples": [
        {
          "code": "int isPositive(int n) {\n    if (n > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
          "explanation": "Returns 1 if n is positive, 0 otherwise."
        },
        {
          "code": "int bigger(int a, int b) {\n    if (a > b) {\n        return a;\n    }\n    return b;\n}",
          "explanation": "Returns a if it's bigger, otherwise returns b."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L03_Q1"},
        {"x": 288, "y": 224, "quest_id": "L03_Q2"},
        {"x": 416, "y": 224, "quest_id": "L03_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L03_Q1",
        "order": 1,
        "title": "Maximum Value",
        "description": "Return the larger of two numbers to impress the guard.",
        "recommended": true,
        "function_signature": {
          "name": "maxValue",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
          ]
        },
        "user_template": "int maxValue(int a, int b) {\n    // Return the larger of a and b\n    \n}",
        "test_cases": [
          {"input": [3, 7], "expected": "7", "sample": true},
          {"input": [10, 2], "expected": "10", "sample": true},
          {"input": [5, 5], "expected": "5", "sample": false},
          {"input": [-3, -7], "expected": "-3", "sample": false}
        ],
        "hints": [
          "Use if (a > b) to compare",
          "Return the larger value in each branch"
        ],
        "xp_reward": 30
      },
      {
        "id": "L03_Q2",
        "order": 2,
        "title": "Even or Odd",
        "description": "Determine if a number is even (return 1) or odd (return 0).",
        "recommended": false,
        "function_signature": {
          "name": "isEven",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int isEven(int n) {\n    // Return 1 if n is even, 0 if odd\n    \n}",
        "test_cases": [
          {"input": [4], "expected": "1", "sample": true},
          {"input": [7], "expected": "0", "sample": true},
          {"input": [0], "expected": "1", "sample": false},
          {"input": [-2], "expected": "1", "sample": false}
        ],
        "hints": [
          "Use the modulo operator: n % 2",
          "Even numbers have n % 2 == 0"
        ],
        "xp_reward": 35
      },
      {
        "id": "L03_Q3",
        "order": 3,
        "title": "Clamp Value",
        "description": "Keep a value within bounds: if below min, return min; if above max, return max.",
        "recommended": false,
        "function_signature": {
          "name": "clamp",
          "return_type": "int",
          "parameters": [
            {"name": "value", "type": "int"},
            {"name": "min", "type": "int"},
            {"name": "max", "type": "int"}
          ]
        },
        "user_template": "int clamp(int value, int min, int max) {\n    // Return value bounded between min and max\n    \n}",
        "test_cases": [
          {"input": [5, 0, 10], "expected": "5", "sample": true},
          {"input": [-5, 0, 10], "expected": "0", "sample": true},
          {"input": [15, 0, 10], "expected": "10", "sample": false},
          {"input": [50, 0, 100], "expected": "50", "sample": false}
        ],
        "hints": [
          "Check if value < min first",
          "Then check if value > max",
          "Otherwise return value unchanged"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L04",
    "title": "The Repeating Strike",
    "theme": "L04_forest",
    "concept": "loops",
    "description": "Master the art of repetition with for loops!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 120,
    "map_file": "maps/L04_forest.json",
    "challenges": [],
    "lesson": {
      "title": "Loops for Repetition",
      "content": [
        "Loops let you repeat code multiple times. The for loop is perfect when you know how many times to repeat.",
        "A for loop has three parts: initialization (int i = 1), condition (i <= n), and update (i++).",
        "The loop body executes repeatedly while the condition is true. Use a variable to accumulate results across iterations."
      ],
      "examples": [
        {
          "code": "int countTo(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum = sum + i;\n    }\n    return sum;\n}",
          "explanation": "This loop adds 1+2+3+...+n by accumulating each value."
        },
        {
          "code": "int multiply(int base, int times) {\n    int result = 0;\n    for (int i = 0; i < times; i++) {\n        result = result + base;\n    }\n    return result;\n}",
          "explanation": "Multiplication through repeated addition."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L04_Q1"},
        {"x": 288, "y": 224, "quest_id": "L04_Q2"},
        {"x": 416, "y": 224, "quest_id": "L04_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L04_Q1",
        "order": 1,
        "title": "Sum of Strikes",
        "description": "Calculate the sum of all strikes from 1 to n.",
        "recommended": true,
        "function_signature": {
          "name": "sumStrikes",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int sumStrikes(int n) {\n    // Return the sum of 1 + 2 + 3 + ... + n\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "15", "sample": true},
          {"input": [10], "expected": "55", "sample": true},
          {"input": [1], "expected": "1", "sample": false},
          {"input": [100], "expected": "5050", "sample": false}
        ],
        "hints": [
          "Use a for loop: for(int i = 1; i <= n; i++)",
          "Accumulate: sum = sum + i"
        ],
        "xp_reward": 35
      },
      {
        "id": "L04_Q2",
        "order": 2,
        "title": "Factorial",
        "description": "Compute n! (n factorial = n × (n-1) × ... × 1).",
        "recommended": false,
        "function_signature": {
          "name": "factorial",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int factorial(int n) {\n    // Return n! = n * (n-1) * ... * 1\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "120", "sample": true},
          {"input": [3], "expected": "6", "sample": true},
          {"input": [1], "expected": "1", "sample": false},
          {"input": [0], "expected": "1", "sample": false}
        ],
        "hints": [
          "Start with result = 1",
          "Multiply: result = result * i"
        ],
        "xp_reward": 40
      },
      {
        "id": "L04_Q3",
        "order": 3,
        "title": "Count Divisible",
        "description": "Count how many numbers from 1 to n are divisible by d.",
        "recommended": false,
        "function_signature": {
          "name": "countDivisible",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"},
            {"name": "d", "type": "int"}
          ]
        },
        "user_template": "int countDivisible(int n, int d) {\n    // Count numbers from 1 to n divisible by d\n    \n}",
        "test_cases": [
          {"input": [10, 2], "expected": "5", "sample": true},
          {"input": [10, 3], "expected": "3", "sample": true},
          {"input": [5, 7], "expected": "0", "sample": false},
          {"input": [100, 10], "expected": "10", "sample": false}
        ],
        "hints": [
          "Use if inside the loop",
          "Check: if (i % d == 0) count++"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L05",
    "title": "Array Fortress",
    "theme": "L05_darkwoods",
    "concept": "arrays",
    "description": "A fortress of many rooms. Master array access and iteration!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L05_darkwoods.json",
    "challenges": [],
    "lesson": {
      "title": "Arrays: Collections of Data",
      "content": [
        "Arrays let you store multiple values of the same type in a single variable. Each value has an index (position number).",
        "IMPORTANT: Array indices start at 0! The first element is at index 0, the second at index 1, and so on.",
        "Access array elements with square brackets: arr[0] gets the first element, arr[2] gets the third."
      ],
      "examples": [
        {
          "code": "int getFirst() {\n    int rooms[3] = {10, 20, 30};\n    return rooms[0];\n}",
          "explanation": "Returns 10 - the element at index 0 (first position)."
        },
        {
          "code": "int getThird() {\n    int data[5] = {5, 10, 15, 20, 25};\n    return data[2];\n}",
          "explanation": "Returns 15 - the element at index 2 (third position)."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L05_Q1"},
        {"x": 288, "y": 224, "quest_id": "L05_Q2"},
        {"x": 416, "y": 224, "quest_id": "L05_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L05_Q1",
        "order": 1,
        "title": "Room Access",
        "description": "Return the value at a specific room index from {10, 20, 30, 40, 50}.",
        "recommended": true,
        "function_signature": {
          "name": "getRoom",
          "return_type": "int",
          "parameters": [
            {"name": "index", "type": "int"}
          ]
        },
        "user_template": "int getRoom(int index) {\n    int rooms[5] = {10, 20, 30, 40, 50};\n    // Return the element at 'index'\n    \n}",
        "test_cases": [
          {"input": [0], "expected": "10", "sample": true},
          {"input": [2], "expected": "30", "sample": true},
          {"input": [4], "expected": "50", "sample": false},
          {"input": [1], "expected": "20", "sample": false}
        ],
        "hints": [
          "Use rooms[index] to access the element",
          "Array indices start at 0"
        ],
        "xp_reward": 30
      },
      {
        "id": "L05_Q2",
        "order": 2,
        "title": "Sum All Rooms",
        "description": "Sum all elements in the rooms array {10, 20, 30, 40, 50}.",
        "recommended": false,
        "function_signature": {
          "name": "sumRooms",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int sumRooms() {\n    int rooms[5] = {10, 20, 30, 40, 50};\n    // Return the sum of all elements\n    \n}",
        "test_cases": [
          {"input": [], "expected": "150", "sample": true}
        ],
        "hints": [
          "Use a for loop to iterate through the array",
          "for (int i = 0; i < 5; i++) sum += rooms[i]"
        ],
        "xp_reward": 35
      },
      {
        "id": "L05_Q3",
        "order": 3,
        "title": "Find Maximum",
        "description": "Find the maximum value in {15, 42, 8, 23, 31}.",
        "recommended": false,
        "function_signature": {
          "name": "findMax",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int findMax() {\n    int values[5] = {15, 42, 8, 23, 31};\n    // Return the maximum value\n    \n}",
        "test_cases": [
          {"input": [], "expected": "42", "sample": true}
        ],
        "hints": [
          "Start with max = values[0]",
          "Compare each element: if (values[i] > max) max = values[i]"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L06",
    "title": "The Spell Scroll",
    "theme": "L06_river",
    "concept": "void functions",
    "description": "Learn to create functions that perform actions without returning values.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L06_river.json",
    "challenges": [],
    "lesson": {
      "title": "Void Functions",
      "content": [
        "Not all functions need to return a value. Void functions perform actions (like printing) without returning anything.",
        "Declare with 'void' as the return type: void functionName() { }",
        "Void functions can still take parameters to customize their behavior."
      ],
      "examples": [
        {
          "code": "void sayHello() {\n    printf(\"Hello!\\n\");\n}",
          "explanation": "A simple void function that prints a greeting."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 192, "y": 224, "quest_id": "L06_Q1"},
        {"x": 384, "y": 224, "quest_id": "L06_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L06_Q1",
        "order": 1,
        "title": "Cast Spell",
        "description": "Create a void function that prints the magic word.",
        "recommended": true,
        "function_signature": {
          "name": "castSpell",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int castSpell() {\n    // Print \"Abracadabra!\" and return 1\n    \n}",
        "test_cases": [
          {"input": [], "expected": "1", "sample": true}
        ],
        "hints": [
          "Use printf(\"Abracadabra!\\n\");",
          "Return 1 to indicate success"
        ],
        "xp_reward": 30
      },
      {
        "id": "L06_Q2",
        "order": 2,
        "title": "Print Square",
        "description": "Print the square of a number (n × n).",
        "recommended": false,
        "function_signature": {
          "name": "printSquare",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int printSquare(int n) {\n    // Print n * n and return the result\n    \n}",
        "test_cases": [
          {"input": [3], "expected": "9", "sample": true},
          {"input": [5], "expected": "25", "sample": true},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Calculate n * n",
          "Return the squared value"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L07",
    "title": "The Damage Calculator",
    "theme": "L07_cavern",
    "concept": "return values",
    "description": "Master functions that compute and return values.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L07_cavern.json",
    "challenges": [],
    "lesson": {
      "title": "Functions with Return Values",
      "content": [
        "Functions can compute values and send them back using the return statement.",
        "The return type (int, float, etc.) must match what you return.",
        "Use returned values in expressions: int result = myFunction(5);"
      ],
      "examples": [
        {
          "code": "int multiply(int a, int b) {\n    return a * b;\n}",
          "explanation": "Returns the product of two numbers."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L07_Q1"},
        {"x": 288, "y": 224, "quest_id": "L07_Q2"},
        {"x": 416, "y": 224, "quest_id": "L07_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L07_Q1",
        "order": 1,
        "title": "Calculate Damage",
        "description": "Compute damage as base × multiplier.",
        "recommended": true,
        "function_signature": {
          "name": "damage",
          "return_type": "int",
          "parameters": [
            {"name": "base", "type": "int"},
            {"name": "mult", "type": "int"}
          ]
        },
        "user_template": "int damage(int base, int mult) {\n    // Return base * mult\n    \n}",
        "test_cases": [
          {"input": [10, 3], "expected": "30", "sample": true},
          {"input": [5, 5], "expected": "25", "sample": true},
          {"input": [100, 0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Multiply the parameters",
          "return base * mult;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L07_Q2",
        "order": 2,
        "title": "Square Number",
        "description": "Return n squared (n × n).",
        "recommended": false,
        "function_signature": {
          "name": "square",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int square(int n) {\n    // Return n * n\n    \n}",
        "test_cases": [
          {"input": [4], "expected": "16", "sample": true},
          {"input": [7], "expected": "49", "sample": true},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Multiply n by itself",
          "return n * n;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L07_Q3",
        "order": 3,
        "title": "Absolute Value",
        "description": "Return the absolute value of n (make negative numbers positive).",
        "recommended": false,
        "function_signature": {
          "name": "absolute",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int absolute(int n) {\n    // Return the absolute value of n\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "5", "sample": true},
          {"input": [-5], "expected": "5", "sample": true},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "If n is negative, return -n",
          "Otherwise return n as-is"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L08",
    "title": "The Stack Spire",
    "theme": "L08_mountain",
    "concept": "stack frames",
    "description": "Understand how functions call each other and return values.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L08_mountain.json",
    "challenges": [],
    "lesson": {
      "title": "Function Calls and the Stack",
      "content": [
        "When a function calls another function, execution 'pauses' the caller until the called function returns.",
        "Functions can call other functions, building a 'stack' of active calls.",
        "Each function's local variables live in its own 'stack frame'."
      ],
      "examples": [
        {
          "code": "int addOne(int n) {\n    return n + 1;\n}\n\nint addTwo(int n) {\n    return addOne(addOne(n));\n}",
          "explanation": "addTwo calls addOne twice, chaining the results."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 192, "y": 224, "quest_id": "L08_Q1"},
        {"x": 384, "y": 224, "quest_id": "L08_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L08_Q1",
        "order": 1,
        "title": "Add One",
        "description": "Create a simple helper that adds 1 to a number.",
        "recommended": true,
        "function_signature": {
          "name": "addOne",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int addOne(int n) {\n    // Return n + 1\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "6", "sample": true},
          {"input": [0], "expected": "1", "sample": true},
          {"input": [-1], "expected": "0", "sample": false}
        ],
        "hints": [
          "Simply return n + 1"
        ],
        "xp_reward": 30
      },
      {
        "id": "L08_Q2",
        "order": 2,
        "title": "Double Add One",
        "description": "Call addOne twice: addOne(addOne(n)) to add 2.",
        "recommended": false,
        "function_signature": {
          "name": "doubleAddOne",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int addOne(int n) {\n    return n + 1;\n}\n\nint doubleAddOne(int n) {\n    // Call addOne twice to add 2\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "7", "sample": true},
          {"input": [0], "expected": "2", "sample": true},
          {"input": [-2], "expected": "0", "sample": false}
        ],
        "hints": [
          "Chain the calls: addOne(addOne(n))",
          "This adds 1, then adds 1 again"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L09",
    "title": "The Global Artifact",
    "theme": "L09_ice",
    "concept": "scope",
    "description": "Understand global vs local variable visibility.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L09_ice.json",
    "challenges": [],
    "lesson": {
      "title": "Variable Scope",
      "content": [
        "Global variables (declared outside functions) are visible everywhere in the file.",
        "Local variables (inside a function) are only visible within that function.",
        "If a local variable has the same name as a global, the local 'shadows' the global."
      ],
      "examples": [
        {
          "code": "int power = 100; // global\n\nint getPower() {\n    return power; // reads global\n}",
          "explanation": "Functions can access global variables directly."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 192, "y": 224, "quest_id": "L09_Q1"},
        {"x": 384, "y": 224, "quest_id": "L09_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L09_Q1",
        "order": 1,
        "title": "Read Global",
        "description": "Access the global artifact variable (value 100).",
        "recommended": true,
        "function_signature": {
          "name": "readGlobal",
          "return_type": "int",
          "parameters": []
        },
        "user_template": "int artifact = 100;  // Global variable\n\nint readGlobal() {\n    // Return the global artifact value\n    \n}",
        "test_cases": [
          {"input": [], "expected": "100", "sample": true}
        ],
        "hints": [
          "Simply return artifact;",
          "Global variables are accessible from any function"
        ],
        "xp_reward": 30
      },
      {
        "id": "L09_Q2",
        "order": 2,
        "title": "Local Shadow",
        "description": "A local parameter shadows the global. Return the local value.",
        "recommended": false,
        "function_signature": {
          "name": "localShadow",
          "return_type": "int",
          "parameters": [
            {"name": "artifact", "type": "int"}
          ]
        },
        "user_template": "int artifact = 100;  // Global (shadowed)\n\nint localShadow(int artifact) {\n    // Return the parameter (shadows global)\n    \n}",
        "test_cases": [
          {"input": [50], "expected": "50", "sample": true},
          {"input": [0], "expected": "0", "sample": true},
          {"input": [999], "expected": "999", "sample": false}
        ],
        "hints": [
          "The parameter 'artifact' shadows the global",
          "Return the parameter value"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L10",
    "title": "The Recursive Mirror",
    "theme": "L10_temple",
    "concept": "recursion",
    "description": "Master functions that call themselves with base cases.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 120,
    "map_file": "maps/L10_temple.json",
    "challenges": [],
    "lesson": {
      "title": "Recursion",
      "content": [
        "Recursion is when a function calls itself to solve smaller subproblems.",
        "Every recursive function needs a BASE CASE to stop the recursion.",
        "The recursive case breaks the problem into smaller pieces."
      ],
      "examples": [
        {
          "code": "int sumTo(int n) {\n    if (n <= 0) return 0;  // base\n    return n + sumTo(n - 1);  // recursive\n}",
          "explanation": "Sums 1 to n by adding n to the sum of 1 to n-1."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L10_Q1"},
        {"x": 288, "y": 224, "quest_id": "L10_Q2"},
        {"x": 416, "y": 224, "quest_id": "L10_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L10_Q1",
        "order": 1,
        "title": "Recursive Sum",
        "description": "Sum 1 to n using recursion (not a loop).",
        "recommended": true,
        "function_signature": {
          "name": "sumToN",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int sumToN(int n) {\n    // Base case: if n <= 0, return 0\n    // Recursive: return n + sumToN(n - 1)\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "15", "sample": true},
          {"input": [1], "expected": "1", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [10], "expected": "55", "sample": false}
        ],
        "hints": [
          "Base case: if (n <= 0) return 0;",
          "Recursive: return n + sumToN(n - 1);"
        ],
        "xp_reward": 35
      },
      {
        "id": "L10_Q2",
        "order": 2,
        "title": "Recursive Power",
        "description": "Calculate base^exp using recursion.",
        "recommended": false,
        "function_signature": {
          "name": "power",
          "return_type": "int",
          "parameters": [
            {"name": "base", "type": "int"},
            {"name": "exp", "type": "int"}
          ]
        },
        "user_template": "int power(int base, int exp) {\n    // Base case: if exp == 0, return 1\n    // Recursive: return base * power(base, exp - 1)\n    \n}",
        "test_cases": [
          {"input": [2, 3], "expected": "8", "sample": true},
          {"input": [3, 2], "expected": "9", "sample": true},
          {"input": [5, 0], "expected": "1", "sample": false},
          {"input": [2, 10], "expected": "1024", "sample": false}
        ],
        "hints": [
          "Base case: any number to the power 0 is 1",
          "Recursive: multiply base by power(base, exp-1)"
        ],
        "xp_reward": 40
      },
      {
        "id": "L10_Q3",
        "order": 3,
        "title": "Fibonacci",
        "description": "Return the nth Fibonacci number (0, 1, 1, 2, 3, 5, 8...).",
        "recommended": false,
        "function_signature": {
          "name": "fib",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int fib(int n) {\n    // Base cases: fib(0) = 0, fib(1) = 1\n    // Recursive: fib(n) = fib(n-1) + fib(n-2)\n    \n}",
        "test_cases": [
          {"input": [6], "expected": "8", "sample": true},
          {"input": [0], "expected": "0", "sample": true},
          {"input": [1], "expected": "1", "sample": false},
          {"input": [10], "expected": "55", "sample": false}
        ],
        "hints": [
          "Two base cases: n==0 returns 0, n==1 returns 1",
          "Recursive: return fib(n-1) + fib(n-2)"
        ],
        "xp_reward": 45
      }
    ]
  },
  {
    "id": "L11",
    "title": "The Address Spell",
    "theme": "L11_library",
    "concept": "address-of operator",
    "description": "Learn to work with memory addresses through pointers.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 55,
    "map_file": "maps/L11_library.json",
    "challenges": [],
    "lesson": {
      "title": "Pointers and Memory Addresses",
      "content": [
        "Every variable in C has a memory address where its value is stored.",
        "A pointer is a variable that holds a memory address. Declare with: int *ptr;",
        "When a function receives a pointer parameter, it can read the value at that address using the * operator."
      ],
      "examples": [
        {
          "code": "int readValue(int *ptr) {\n    return *ptr;\n}",
          "explanation": "The function receives an address and returns the value stored there."
        },
        {
          "code": "int sum(int *a, int *b) {\n    return *a + *b;\n}",
          "explanation": "Reads values at two addresses and returns their sum."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L11_Q1"},
        {"x": 416, "y": 224, "quest_id": "L11_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L11_Q1",
        "order": 1,
        "title": "Read Via Pointer",
        "description": "Return the value stored at the address the pointer points to.",
        "recommended": true,
        "function_signature": {
          "name": "readValue",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int readValue(int *ptr) {\n    // Return the value at the address ptr points to\n    // Use *ptr to dereference the pointer\n    \n}",
        "test_cases": [
          {"input": [42], "expected": "42", "sample": true},
          {"input": [100], "expected": "100", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [-5], "expected": "-5", "sample": false}
        ],
        "hints": [
          "Use *ptr to get the value at the address",
          "Example: return *ptr;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L11_Q2",
        "order": 2,
        "title": "Add Via Pointers",
        "description": "Return the sum of values at two different addresses.",
        "recommended": false,
        "function_signature": {
          "name": "addValues",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int*"},
            {"name": "b", "type": "int*"}
          ]
        },
        "user_template": "int addValues(int *a, int *b) {\n    // Return the sum of values at addresses a and b\n    \n}",
        "test_cases": [
          {"input": [3, 4], "expected": "7", "sample": true},
          {"input": [10, 20], "expected": "30", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [-5, 5], "expected": "0", "sample": false}
        ],
        "hints": [
          "Dereference both pointers: *a and *b",
          "Return their sum: return *a + *b;"
        ],
        "xp_reward": 30
      }
    ]
  },
  {
    "id": "L12",
    "title": "The Grappling Hook",
    "theme": "L12_crypt",
    "concept": "pointer declaration",
    "description": "Master pointer declarations and learn to grab values from a distance!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 90,
    "map_file": "maps/L12_crypt.json",
    "challenges": [],
    "lesson": {
      "title": "Declaring and Using Pointers",
      "content": [
        "Declare a pointer with: int *ptr; (a pointer to an integer)",
        "The * in declarations means 'pointer to'. In expressions, * means 'dereference'.",
        "Functions can modify values through pointers, allowing changes to persist outside the function."
      ],
      "examples": [
        {
          "code": "int getValue(int *ptr) {\n    return *ptr;  // Read value at address\n}",
          "explanation": "Reading a value through a pointer."
        },
        {
          "code": "int doubled(int *ptr) {\n    return *ptr * 2;\n}",
          "explanation": "Use the dereferenced value in calculations."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L12_Q1"},
        {"x": 288, "y": 224, "quest_id": "L12_Q2"},
        {"x": 416, "y": 224, "quest_id": "L12_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L12_Q1",
        "order": 1,
        "title": "Grab the Value",
        "description": "Return the value your pointer hook is aimed at.",
        "recommended": true,
        "function_signature": {
          "name": "grab",
          "return_type": "int",
          "parameters": [
            {"name": "hook", "type": "int*"}
          ]
        },
        "user_template": "int grab(int *hook) {\n    // Return the value that hook points to\n    \n}",
        "test_cases": [
          {"input": [100], "expected": "100", "sample": true},
          {"input": [42], "expected": "42", "sample": true},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Use *hook to dereference the pointer",
          "return *hook;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L12_Q2",
        "order": 2,
        "title": "Double the Treasure",
        "description": "Return double the value at the pointer's location.",
        "recommended": false,
        "function_signature": {
          "name": "doubleTreasure",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int doubleTreasure(int *ptr) {\n    // Return the value at ptr multiplied by 2\n    \n}",
        "test_cases": [
          {"input": [50], "expected": "100", "sample": true},
          {"input": [7], "expected": "14", "sample": true},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Dereference and multiply: *ptr * 2",
          "return *ptr * 2;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L12_Q3",
        "order": 3,
        "title": "Add to Pointer Value",
        "description": "Return the value at ptr plus an additional amount.",
        "recommended": false,
        "function_signature": {
          "name": "addToValue",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"},
            {"name": "add", "type": "int"}
          ]
        },
        "user_template": "int addToValue(int *ptr, int add) {\n    // Return the value at ptr plus the add amount\n    \n}",
        "test_cases": [
          {"input": [10, 5], "expected": "15", "sample": true},
          {"input": [100, 50], "expected": "150", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [10, -3], "expected": "7", "sample": false}
        ],
        "hints": [
          "Mix pointer dereference with regular parameter",
          "return *ptr + add;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L13",
    "title": "The Dereference Pull",
    "theme": "L13_lake",
    "concept": "dereference operator",
    "description": "Learn to modify values through pointers - the key to powerful functions!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L13_lake.json",
    "challenges": [],
    "lesson": {
      "title": "Modifying Values Through Pointers",
      "content": [
        "The dereference operator (*) lets you both read AND write values at an address.",
        "Writing: *ptr = value; changes what ptr points to.",
        "This is how functions can modify variables from their caller - by receiving pointers."
      ],
      "examples": [
        {
          "code": "void setTo42(int *ptr) {\n    *ptr = 42;\n}",
          "explanation": "Sets the value at ptr's address to 42."
        },
        {
          "code": "int setAndReturn(int *ptr, int val) {\n    *ptr = val;\n    return *ptr;\n}",
          "explanation": "Modifies through pointer and returns the new value."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L13_Q1"},
        {"x": 288, "y": 224, "quest_id": "L13_Q2"},
        {"x": 416, "y": 224, "quest_id": "L13_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L13_Q1",
        "order": 1,
        "title": "Set and Read",
        "description": "Set the value at ptr to val and return it to confirm the change.",
        "recommended": true,
        "function_signature": {
          "name": "setAndRead",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"},
            {"name": "val", "type": "int"}
          ]
        },
        "user_template": "int setAndRead(int *ptr, int val) {\n    // Set *ptr to val, then return *ptr\n    \n}",
        "test_cases": [
          {"input": [0, 42], "expected": "42", "sample": true},
          {"input": [100, 200], "expected": "200", "sample": true},
          {"input": [5, 5], "expected": "5", "sample": false}
        ],
        "hints": [
          "First set: *ptr = val;",
          "Then return: return *ptr;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L13_Q2",
        "order": 2,
        "title": "Increment Through Pointer",
        "description": "Increase the value at ptr by 1 and return the new value.",
        "recommended": false,
        "function_signature": {
          "name": "incrementAndRead",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int incrementAndRead(int *ptr) {\n    // Add 1 to *ptr and return the new value\n    \n}",
        "test_cases": [
          {"input": [10], "expected": "11", "sample": true},
          {"input": [0], "expected": "1", "sample": true},
          {"input": [-1], "expected": "0", "sample": false},
          {"input": [99], "expected": "100", "sample": false}
        ],
        "hints": [
          "Modify: *ptr = *ptr + 1; or (*ptr)++;",
          "Return the updated value"
        ],
        "xp_reward": 35
      },
      {
        "id": "L13_Q3",
        "order": 3,
        "title": "Double In Place",
        "description": "Double the value at ptr and return it.",
        "recommended": false,
        "function_signature": {
          "name": "doubleInPlace",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int doubleInPlace(int *ptr) {\n    // Double the value at ptr and return it\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "10", "sample": true},
          {"input": [7], "expected": "14", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [50], "expected": "100", "sample": false}
        ],
        "hints": [
          "Multiply: *ptr = *ptr * 2;",
          "Or use: *ptr *= 2;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L14",
    "title": "The Array Navigator",
    "theme": "L14_forge",
    "concept": "pointer arithmetic",
    "description": "Navigate arrays using pointer arithmetic - the foundation of efficient C programming!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 105,
    "map_file": "maps/L14_forge.json",
    "challenges": [],
    "lesson": {
      "title": "Pointer Arithmetic and Arrays",
      "content": [
        "In C, arrays and pointers are closely related. An array name IS a pointer to its first element.",
        "Adding n to a pointer moves it forward by n elements: *(arr + 2) is the same as arr[2].",
        "Use pointer arithmetic to traverse arrays efficiently in loops."
      ],
      "examples": [
        {
          "code": "int getAt(int *arr, int i) {\n    return *(arr + i);  // or arr[i]\n}",
          "explanation": "Access element at index i using pointer arithmetic."
        },
        {
          "code": "int sum(int *arr, int n) {\n    int total = 0;\n    for(int i = 0; i < n; i++)\n        total += *(arr + i);\n    return total;\n}",
          "explanation": "Sum array elements using pointer arithmetic in a loop."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L14_Q1"},
        {"x": 288, "y": 224, "quest_id": "L14_Q2"},
        {"x": 416, "y": 224, "quest_id": "L14_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L14_Q1",
        "order": 1,
        "title": "Navigate to Index",
        "description": "Return the element at index i from the array using pointer arithmetic.",
        "recommended": true,
        "function_signature": {
          "name": "getAt",
          "return_type": "int",
          "parameters": [
            {"name": "arr", "type": "int*"},
            {"name": "i", "type": "int"}
          ]
        },
        "user_template": "int getAt(int *arr, int i) {\n    // Return the element at index i\n    // Use *(arr + i) or arr[i]\n    \n}",
        "test_cases": [
          {"input": [[10, 20, 30, 40, 50], 2], "expected": "30", "sample": true},
          {"input": [[10, 20, 30, 40, 50], 0], "expected": "10", "sample": true},
          {"input": [[10, 20, 30, 40, 50], 4], "expected": "50", "sample": false}
        ],
        "hints": [
          "Use *(arr + i) to access the element",
          "This is equivalent to arr[i]"
        ],
        "xp_reward": 30
      },
      {
        "id": "L14_Q2",
        "order": 2,
        "title": "Sum Array Elements",
        "description": "Sum all n elements of the array using pointer arithmetic.",
        "recommended": false,
        "function_signature": {
          "name": "sumArray",
          "return_type": "int",
          "parameters": [
            {"name": "arr", "type": "int*"},
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int sumArray(int *arr, int n) {\n    // Sum all n elements using pointer arithmetic\n    int sum = 0;\n    \n    return sum;\n}",
        "test_cases": [
          {"input": [[1, 2, 3], 3], "expected": "6", "sample": true},
          {"input": [[10, 20, 30, 40], 4], "expected": "100", "sample": true},
          {"input": [[5], 1], "expected": "5", "sample": false},
          {"input": [[0, 0, 0], 3], "expected": "0", "sample": false}
        ],
        "hints": [
          "Use a for loop: for(int i = 0; i < n; i++)",
          "Add each element: sum += *(arr + i);"
        ],
        "xp_reward": 35
      },
      {
        "id": "L14_Q3",
        "order": 3,
        "title": "Find Element Index",
        "description": "Find the index of target in the array. Return -1 if not found.",
        "recommended": false,
        "function_signature": {
          "name": "findIndex",
          "return_type": "int",
          "parameters": [
            {"name": "arr", "type": "int*"},
            {"name": "n", "type": "int"},
            {"name": "target", "type": "int"}
          ]
        },
        "user_template": "int findIndex(int *arr, int n, int target) {\n    // Find target in arr and return its index\n    // Return -1 if not found\n    \n}",
        "test_cases": [
          {"input": [[5, 10, 15, 20], 4, 15], "expected": "2", "sample": true},
          {"input": [[5, 10, 15, 20], 4, 5], "expected": "0", "sample": true},
          {"input": [[5, 10, 15, 20], 4, 99], "expected": "-1", "sample": false},
          {"input": [[42], 1, 42], "expected": "0", "sample": false}
        ],
        "hints": [
          "Loop through the array comparing each element",
          "if (*(arr + i) == target) return i;",
          "Return -1 after the loop if not found"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L15",
    "title": "The Null Trap",
    "theme": "L15_lair",
    "concept": "null pointers",
    "description": "Learn to safely handle null pointers and avoid the dreaded SEGFAULT!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L15_lair.json",
    "challenges": [],
    "lesson": {
      "title": "Null Pointer Safety",
      "content": [
        "NULL is a special value meaning 'points to nothing'. Dereferencing NULL crashes your program!",
        "Always check if a pointer is NULL before using it: if (ptr != NULL)",
        "Functions should return safe defaults when given NULL pointers."
      ],
      "examples": [
        {
          "code": "int safeRead(int *ptr) {\n    if (ptr == NULL) return -1;\n    return *ptr;\n}",
          "explanation": "Returns -1 for NULL, otherwise the actual value."
        },
        {
          "code": "int isValid(int *ptr) {\n    return ptr != NULL;\n}",
          "explanation": "Returns 1 if pointer is valid, 0 if NULL."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L15_Q1"},
        {"x": 288, "y": 224, "quest_id": "L15_Q2"},
        {"x": 416, "y": 224, "quest_id": "L15_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L15_Q1",
        "order": 1,
        "title": "Safe Read",
        "description": "Return the value at ptr, or -1 if ptr is NULL.",
        "recommended": true,
        "function_signature": {
          "name": "safeRead",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int safeRead(int *ptr) {\n    // Return *ptr if valid, or -1 if NULL\n    \n}",
        "test_cases": [
          {"input": [42], "expected": "42", "sample": true},
          {"input": [100], "expected": "100", "sample": true},
          {"input": ["NULL"], "expected": "-1", "sample": false},
          {"input": [0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Check: if (ptr == NULL) return -1;",
          "Otherwise: return *ptr;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L15_Q2",
        "order": 2,
        "title": "Is Valid Pointer",
        "description": "Return 1 if the pointer is valid (not NULL), 0 if NULL.",
        "recommended": false,
        "function_signature": {
          "name": "isValid",
          "return_type": "int",
          "parameters": [
            {"name": "ptr", "type": "int*"}
          ]
        },
        "user_template": "int isValid(int *ptr) {\n    // Return 1 if ptr is not NULL, 0 if NULL\n    \n}",
        "test_cases": [
          {"input": [42], "expected": "1", "sample": true},
          {"input": ["NULL"], "expected": "0", "sample": true},
          {"input": [0], "expected": "1", "sample": false}
        ],
        "hints": [
          "Compare ptr to NULL",
          "return ptr != NULL;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L15_Q3",
        "order": 3,
        "title": "Safe Add",
        "description": "Return *a + *b if both pointers are valid. Return 0 if either is NULL.",
        "recommended": false,
        "function_signature": {
          "name": "safeAdd",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int*"},
            {"name": "b", "type": "int*"}
          ]
        },
        "user_template": "int safeAdd(int *a, int *b) {\n    // Return *a + *b if both valid, 0 if either is NULL\n    \n}",
        "test_cases": [
          {"input": [3, 4], "expected": "7", "sample": true},
          {"input": [10, 20], "expected": "30", "sample": true},
          {"input": ["NULL", 5], "expected": "0", "sample": false},
          {"input": [5, "NULL"], "expected": "0", "sample": false}
        ],
        "hints": [
          "Check both: if (a == NULL || b == NULL)",
          "Return 0 for invalid, *a + *b for valid"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L16",
    "title": "The Blueprint Scroll",
    "theme": "L16_courtyard",
    "concept": "struct definition",
    "description": "Learn to group related data together using structs!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 95,
    "map_file": "maps/L16_courtyard.json",
    "challenges": [],
    "lesson": {
      "title": "Structs: Custom Data Types",
      "content": [
        "A struct groups related variables together into a single unit.",
        "Define with: struct Hero { int hp; int level; };",
        "Access members with dot notation: hero.hp, hero.level"
      ],
      "examples": [
        {
          "code": "struct Hero {\n    int hp;\n    int level;\n};",
          "explanation": "Defines a Hero type with hp and level fields."
        },
        {
          "code": "int getHP(struct Hero h) {\n    return h.hp;\n}",
          "explanation": "Functions can receive structs and access their members."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L16_Q1"},
        {"x": 288, "y": 224, "quest_id": "L16_Q2"},
        {"x": 416, "y": 224, "quest_id": "L16_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L16_Q1",
        "order": 1,
        "title": "Get Hero HP",
        "description": "Return the hp field from the Hero struct.",
        "recommended": true,
        "function_signature": {
          "name": "getHP",
          "return_type": "int",
          "parameters": [
            {"name": "hp", "type": "int"},
            {"name": "level", "type": "int"}
          ]
        },
        "user_template": "// struct Hero { int hp; int level; }; is provided\n\nint getHP(int hp, int level) {\n    // Simply return the hp value\n    \n}",
        "test_cases": [
          {"input": [100, 5], "expected": "100", "sample": true},
          {"input": [50, 10], "expected": "50", "sample": true},
          {"input": [0, 1], "expected": "0", "sample": false}
        ],
        "hints": [
          "Just return the hp parameter",
          "return hp;"
        ],
        "xp_reward": 25
      },
      {
        "id": "L16_Q2",
        "order": 2,
        "title": "Is Hero Alive",
        "description": "Return 1 if hp > 0, otherwise return 0.",
        "recommended": false,
        "function_signature": {
          "name": "isAlive",
          "return_type": "int",
          "parameters": [
            {"name": "hp", "type": "int"}
          ]
        },
        "user_template": "int isAlive(int hp) {\n    // Return 1 if hp > 0, else 0\n    \n}",
        "test_cases": [
          {"input": [100], "expected": "1", "sample": true},
          {"input": [0], "expected": "0", "sample": true},
          {"input": [1], "expected": "1", "sample": false},
          {"input": [-5], "expected": "0", "sample": false}
        ],
        "hints": [
          "Compare hp to 0",
          "return hp > 0;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L16_Q3",
        "order": 3,
        "title": "Calculate Power Level",
        "description": "Return hp + (level × 10) as the hero's power level.",
        "recommended": false,
        "function_signature": {
          "name": "powerLevel",
          "return_type": "int",
          "parameters": [
            {"name": "hp", "type": "int"},
            {"name": "level", "type": "int"}
          ]
        },
        "user_template": "int powerLevel(int hp, int level) {\n    // Return hp + level * 10\n    \n}",
        "test_cases": [
          {"input": [100, 5], "expected": "150", "sample": true},
          {"input": [50, 10], "expected": "150", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [200, 20], "expected": "400", "sample": false}
        ],
        "hints": [
          "Multiply level by 10 and add hp",
          "return hp + level * 10;"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L17",
    "title": "The Chest Contents",
    "theme": "L17_throne",
    "concept": "struct members",
    "description": "Access and compute with struct member values!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 100,
    "map_file": "maps/L17_throne.json",
    "challenges": [],
    "lesson": {
      "title": "Working with Struct Members",
      "content": [
        "Use dot notation to access struct members: chest.gold",
        "Members can be read, modified, and used in calculations",
        "Each field acts like a regular variable of its type"
      ],
      "examples": [
        {
          "code": "int getGold(int gold, int gems, int keys) {\n    return gold;\n}",
          "explanation": "Access and return a single field value."
        },
        {
          "code": "int totalValue(int gold, int gems, int keys) {\n    return gold + gems * 10 + keys * 5;\n}",
          "explanation": "Compute a value from multiple fields."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L17_Q1"},
        {"x": 288, "y": 224, "quest_id": "L17_Q2"},
        {"x": 416, "y": 224, "quest_id": "L17_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L17_Q1",
        "order": 1,
        "title": "Get Gold Count",
        "description": "Return the gold amount from the chest.",
        "recommended": true,
        "function_signature": {
          "name": "getGold",
          "return_type": "int",
          "parameters": [
            {"name": "gold", "type": "int"},
            {"name": "gems", "type": "int"},
            {"name": "keys", "type": "int"}
          ]
        },
        "user_template": "// Chest has: gold, gems, keys\n\nint getGold(int gold, int gems, int keys) {\n    // Return the gold amount\n    \n}",
        "test_cases": [
          {"input": [500, 10, 3], "expected": "500", "sample": true},
          {"input": [100, 5, 2], "expected": "100", "sample": true},
          {"input": [0, 0, 0], "expected": "0", "sample": false}
        ],
        "hints": [
          "Simply return the gold parameter",
          "return gold;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L17_Q2",
        "order": 2,
        "title": "Total Chest Value",
        "description": "Calculate total value: gold + gems×10 + keys×5.",
        "recommended": false,
        "function_signature": {
          "name": "totalValue",
          "return_type": "int",
          "parameters": [
            {"name": "gold", "type": "int"},
            {"name": "gems", "type": "int"},
            {"name": "keys", "type": "int"}
          ]
        },
        "user_template": "int totalValue(int gold, int gems, int keys) {\n    // Return gold + gems*10 + keys*5\n    \n}",
        "test_cases": [
          {"input": [100, 5, 2], "expected": "160", "sample": true},
          {"input": [500, 10, 3], "expected": "615", "sample": true},
          {"input": [0, 0, 0], "expected": "0", "sample": false},
          {"input": [0, 10, 10], "expected": "150", "sample": false}
        ],
        "hints": [
          "Multiply gems by 10, keys by 5",
          "return gold + gems * 10 + keys * 5;"
        ],
        "xp_reward": 35
      },
      {
        "id": "L17_Q3",
        "order": 3,
        "title": "Is Chest Empty",
        "description": "Return 1 if all fields are 0, otherwise 0.",
        "recommended": false,
        "function_signature": {
          "name": "isEmpty",
          "return_type": "int",
          "parameters": [
            {"name": "gold", "type": "int"},
            {"name": "gems", "type": "int"},
            {"name": "keys", "type": "int"}
          ]
        },
        "user_template": "int isEmpty(int gold, int gems, int keys) {\n    // Return 1 if all are 0, else 0\n    \n}",
        "test_cases": [
          {"input": [0, 0, 0], "expected": "1", "sample": true},
          {"input": [1, 0, 0], "expected": "0", "sample": true},
          {"input": [0, 1, 0], "expected": "0", "sample": false},
          {"input": [100, 50, 10], "expected": "0", "sample": false}
        ],
        "hints": [
          "Check all three: gold == 0 && gems == 0 && keys == 0",
          "Use && to combine conditions"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L18",
    "title": "The Teleport Chest",
    "theme": "L18_treasury",
    "concept": "struct pointers",
    "description": "Modify struct values through pointers using the arrow operator!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 95,
    "map_file": "maps/L18_treasury.json",
    "challenges": [],
    "lesson": {
      "title": "Struct Pointers and Arrow Operator",
      "content": [
        "When you have a pointer to a struct, use -> to access members: ptr->field",
        "The arrow operator is shorthand for (*ptr).field",
        "This allows functions to modify struct data in the caller's scope"
      ],
      "examples": [
        {
          "code": "int addGold(int *gold, int amt) {\n    *gold += amt;\n    return *gold;\n}",
          "explanation": "Adds amount to gold through pointer and returns new total."
        },
        {
          "code": "int heal(int *hp, int amt) {\n    *hp += amt;\n    return *hp;\n}",
          "explanation": "Increases HP and returns the new value."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L18_Q1"},
        {"x": 288, "y": 224, "quest_id": "L18_Q2"},
        {"x": 416, "y": 224, "quest_id": "L18_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L18_Q1",
        "order": 1,
        "title": "Add Gold",
        "description": "Add amount to gold and return the new total.",
        "recommended": true,
        "function_signature": {
          "name": "addGold",
          "return_type": "int",
          "parameters": [
            {"name": "gold", "type": "int*"},
            {"name": "amt", "type": "int"}
          ]
        },
        "user_template": "int addGold(int *gold, int amt) {\n    // Add amt to *gold and return the new value\n    \n}",
        "test_cases": [
          {"input": [100, 50], "expected": "150", "sample": true},
          {"input": [0, 25], "expected": "25", "sample": true},
          {"input": [200, 0], "expected": "200", "sample": false}
        ],
        "hints": [
          "Modify through pointer: *gold += amt;",
          "Return the updated value: return *gold;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L18_Q2",
        "order": 2,
        "title": "Heal Hero",
        "description": "Add healing amount to HP and return new HP value.",
        "recommended": false,
        "function_signature": {
          "name": "heal",
          "return_type": "int",
          "parameters": [
            {"name": "hp", "type": "int*"},
            {"name": "amount", "type": "int"}
          ]
        },
        "user_template": "int heal(int *hp, int amount) {\n    // Add amount to *hp and return new hp\n    \n}",
        "test_cases": [
          {"input": [50, 30], "expected": "80", "sample": true},
          {"input": [100, 0], "expected": "100", "sample": true},
          {"input": [0, 50], "expected": "50", "sample": false}
        ],
        "hints": [
          "Add amount to what hp points to",
          "*hp += amount; return *hp;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L18_Q3",
        "order": 3,
        "title": "Level Up",
        "description": "Increase level by 1 and add 10 to HP. Return the new level.",
        "recommended": false,
        "function_signature": {
          "name": "levelUp",
          "return_type": "int",
          "parameters": [
            {"name": "hp", "type": "int*"},
            {"name": "level", "type": "int*"}
          ]
        },
        "user_template": "int levelUp(int *hp, int *level) {\n    // Increase *level by 1, add 10 to *hp\n    // Return the new level\n    \n}",
        "test_cases": [
          {"input": [100, 5], "expected": "6", "sample": true},
          {"input": [50, 1], "expected": "2", "sample": true},
          {"input": [0, 0], "expected": "1", "sample": false}
        ],
        "hints": [
          "Modify both: (*level)++; *hp += 10;",
          "Return the new level value"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L19",
    "title": "The Guild Hierarchy",
    "theme": "L19_dungeon",
    "concept": "nested structs",
    "description": "Work with structs that contain other structs - hierarchical data!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 65,
    "map_file": "maps/L19_dungeon.json",
    "challenges": [],
    "lesson": {
      "title": "Nested Structs",
      "content": [
        "Structs can contain other structs, creating hierarchical data.",
        "Access nested fields with chained dots: guild.leader.level",
        "This models real-world relationships like 'Guild has a Leader who is a Hero'"
      ],
      "examples": [
        {
          "code": "// Guild has leaderLevel and memberCount\nint guildPower(int leaderLevel, int members) {\n    return leaderLevel * members;\n}",
          "explanation": "Calculate guild power from nested data."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L19_Q1"},
        {"x": 416, "y": 224, "quest_id": "L19_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L19_Q1",
        "order": 1,
        "title": "Get Leader Level",
        "description": "Return the leader's level from the guild data.",
        "recommended": true,
        "function_signature": {
          "name": "leaderLevel",
          "return_type": "int",
          "parameters": [
            {"name": "level", "type": "int"}
          ]
        },
        "user_template": "// Guild has a leader with a level\n\nint leaderLevel(int level) {\n    // Return the leader's level\n    \n}",
        "test_cases": [
          {"input": [50], "expected": "50", "sample": true},
          {"input": [10], "expected": "10", "sample": true},
          {"input": [1], "expected": "1", "sample": false}
        ],
        "hints": [
          "Simply return the level parameter",
          "return level;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L19_Q2",
        "order": 2,
        "title": "Calculate Guild Power",
        "description": "Return leaderLevel × memberCount as guild power.",
        "recommended": false,
        "function_signature": {
          "name": "guildPower",
          "return_type": "int",
          "parameters": [
            {"name": "leaderLevel", "type": "int"},
            {"name": "memberCount", "type": "int"}
          ]
        },
        "user_template": "int guildPower(int leaderLevel, int memberCount) {\n    // Return leaderLevel * memberCount\n    \n}",
        "test_cases": [
          {"input": [50, 100], "expected": "5000", "sample": true},
          {"input": [10, 50], "expected": "500", "sample": true},
          {"input": [1, 1], "expected": "1", "sample": false},
          {"input": [0, 100], "expected": "0", "sample": false}
        ],
        "hints": [
          "Multiply the two values",
          "return leaderLevel * memberCount;"
        ],
        "xp_reward": 35
      }
    ]
  },
  {
    "id": "L20",
    "title": "The Army Roster",
    "theme": "L20_passage",
    "concept": "array of structs",
    "description": "Process arrays of structured data - the foundation of real programs!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L20_passage.json",
    "challenges": [],
    "lesson": {
      "title": "Arrays of Structs",
      "content": [
        "Arrays can hold structs just like they hold integers.",
        "Access with: array[i].field (combines array indexing and struct access)",
        "Loop through to process all elements: for(int i = 0; i < n; i++)"
      ],
      "examples": [
        {
          "code": "int totalStrength(int *strengths, int n) {\n    int sum = 0;\n    for(int i = 0; i < n; i++)\n        sum += strengths[i];\n    return sum;\n}",
          "explanation": "Sum all strength values from the army."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L20_Q1"},
        {"x": 288, "y": 224, "quest_id": "L20_Q2"},
        {"x": 416, "y": 224, "quest_id": "L20_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L20_Q1",
        "order": 1,
        "title": "Total Army Strength",
        "description": "Sum all strength values from the soldiers array.",
        "recommended": true,
        "function_signature": {
          "name": "totalStrength",
          "return_type": "int",
          "parameters": [
            {"name": "strengths", "type": "int*"},
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int totalStrength(int *strengths, int n) {\n    // Sum all n strength values\n    int sum = 0;\n    \n    return sum;\n}",
        "test_cases": [
          {"input": [[10, 25, 50], 3], "expected": "85", "sample": true},
          {"input": [[5, 5, 5, 5], 4], "expected": "20", "sample": true},
          {"input": [[100], 1], "expected": "100", "sample": false}
        ],
        "hints": [
          "Loop: for(int i = 0; i < n; i++)",
          "Add each: sum += strengths[i];"
        ],
        "xp_reward": 35
      },
      {
        "id": "L20_Q2",
        "order": 2,
        "title": "Find Strongest Index",
        "description": "Return the index of the soldier with highest strength.",
        "recommended": false,
        "function_signature": {
          "name": "strongestIndex",
          "return_type": "int",
          "parameters": [
            {"name": "strengths", "type": "int*"},
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int strongestIndex(int *strengths, int n) {\n    // Find index of maximum strength\n    int maxIdx = 0;\n    \n    return maxIdx;\n}",
        "test_cases": [
          {"input": [[10, 50, 25], 3], "expected": "1", "sample": true},
          {"input": [[100, 50, 25], 3], "expected": "0", "sample": true},
          {"input": [[10, 25, 50], 3], "expected": "2", "sample": false}
        ],
        "hints": [
          "Track max index, update when you find larger",
          "if(strengths[i] > strengths[maxIdx]) maxIdx = i;"
        ],
        "xp_reward": 35
      },
      {
        "id": "L20_Q3",
        "order": 3,
        "title": "Count Strong Soldiers",
        "description": "Count soldiers with strength >= minStrength.",
        "recommended": false,
        "function_signature": {
          "name": "countStrong",
          "return_type": "int",
          "parameters": [
            {"name": "strengths", "type": "int*"},
            {"name": "n", "type": "int"},
            {"name": "minStrength", "type": "int"}
          ]
        },
        "user_template": "int countStrong(int *strengths, int n, int minStrength) {\n    // Count soldiers with strength >= minStrength\n    int count = 0;\n    \n    return count;\n}",
        "test_cases": [
          {"input": [[10, 25, 50], 3, 20], "expected": "2", "sample": true},
          {"input": [[10, 25, 50], 3, 100], "expected": "0", "sample": true},
          {"input": [[10, 25, 50], 3, 10], "expected": "3", "sample": false}
        ],
        "hints": [
          "Loop and check: if(strengths[i] >= minStrength)",
          "Increment count for each match"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L21",
    "title": "Summon Land",
    "theme": "L21_stairs",
    "concept": "malloc basics",
    "description": "The void stretches before you. Use malloc to summon solid ground from nothingness!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L21_stairs.json",
    "challenges": [],
    "lesson": {
      "title": "Dynamic Memory with Malloc",
      "content": [
        "malloc (memory allocate) requests memory from the system at runtime.",
        "Use: int *ptr = (int*)malloc(sizeof(int)); to allocate space for one integer.",
        "Always check if malloc returned NULL (allocation failed) and always free() when done."
      ],
      "examples": [
        {
          "code": "int mallocAndRead(int val) {\n    int *p = (int*)malloc(sizeof(int));\n    *p = val;\n    int result = *p;\n    free(p);\n    return result;\n}",
          "explanation": "Allocate, store a value, read it back, free, and return."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L21_Q1"},
        {"x": 416, "y": 224, "quest_id": "L21_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L21_Q1",
        "order": 1,
        "title": "Allocate and Read",
        "description": "Malloc an integer, store the given value, read it back, free, and return.",
        "recommended": true,
        "function_signature": {
          "name": "mallocRead",
          "return_type": "int",
          "parameters": [
            {"name": "val", "type": "int"}
          ]
        },
        "user_template": "int mallocRead(int val) {\n    // 1. Allocate memory for one int\n    // 2. Store val in it\n    // 3. Read the value back\n    // 4. Free the memory\n    // 5. Return the value\n    \n}",
        "test_cases": [
          {"input": [42], "expected": "42", "sample": true},
          {"input": [100], "expected": "100", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [-5], "expected": "-5", "sample": false}
        ],
        "hints": [
          "int *p = (int*)malloc(sizeof(int));",
          "*p = val; to store the value",
          "Don't forget to free(p) before returning!"
        ],
        "xp_reward": 30
      },
      {
        "id": "L21_Q2",
        "order": 2,
        "title": "Allocate and Compute",
        "description": "Malloc an integer, compute a + b, store it, read back, free, and return.",
        "recommended": false,
        "function_signature": {
          "name": "mallocSum",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
          ]
        },
        "user_template": "int mallocSum(int a, int b) {\n    // Allocate, compute a+b, store, read, free, return\n    \n}",
        "test_cases": [
          {"input": [3, 4], "expected": "7", "sample": true},
          {"input": [10, 20], "expected": "30", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [100, -50], "expected": "50", "sample": false}
        ],
        "hints": [
          "Compute a + b and store in allocated memory",
          "int *p = (int*)malloc(sizeof(int)); *p = a + b;",
          "Read back with int result = *p; before freeing"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L22",
    "title": "The Banish Spell",
    "theme": "L22_alchemy",
    "concept": "free memory",
    "description": "What you summon, you must also banish! Release the memory back to the void.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L22_alchemy.json",
    "challenges": [],
    "lesson": {
      "title": "Releasing Memory with Free",
      "content": [
        "Every malloc must have a matching free, or you create a memory leak.",
        "Call free(ptr) to release memory. After freeing, the pointer is dangling - don't use it!",
        "Good pattern: allocate, use, free, return result (not the pointer)."
      ],
      "examples": [
        {
          "code": "int computeAndFree(int a, int b) {\n    int *p = (int*)malloc(sizeof(int));\n    *p = a * b;\n    int result = *p;\n    free(p);\n    return result;\n}",
          "explanation": "Allocate, compute, save result, free, then return the saved result."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L22_Q1"},
        {"x": 416, "y": 224, "quest_id": "L22_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L22_Q1",
        "order": 1,
        "title": "Square and Free",
        "description": "Allocate memory, compute n squared, save result, free memory, return result.",
        "recommended": true,
        "function_signature": {
          "name": "squareAndFree",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int squareAndFree(int n) {\n    // 1. Allocate an int\n    // 2. Compute n * n and store it\n    // 3. Save the result to a local variable\n    // 4. Free the memory\n    // 5. Return the saved result\n    \n}",
        "test_cases": [
          {"input": [5], "expected": "25", "sample": true},
          {"input": [3], "expected": "9", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [10], "expected": "100", "sample": false}
        ],
        "hints": [
          "Save result before freeing: int result = *p;",
          "Then free(p); and return result;",
          "Never return a freed pointer!"
        ],
        "xp_reward": 30
      },
      {
        "id": "L22_Q2",
        "order": 2,
        "title": "Double Allocation",
        "description": "Allocate TWO integers, store a and b, compute sum, free both, return sum.",
        "recommended": false,
        "function_signature": {
          "name": "allocTwoSum",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
          ]
        },
        "user_template": "int allocTwoSum(int a, int b) {\n    // Allocate two ints, store a and b, sum them\n    // Free both allocations, return the sum\n    \n}",
        "test_cases": [
          {"input": [10, 20], "expected": "30", "sample": true},
          {"input": [5, 5], "expected": "10", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [100, -50], "expected": "50", "sample": false}
        ],
        "hints": [
          "int *p1 = malloc(...); int *p2 = malloc(...);",
          "Compute sum: int sum = *p1 + *p2;",
          "Free both: free(p1); free(p2);"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L23",
    "title": "The Cursed Hoarding",
    "theme": "L23_observatory",
    "concept": "memory leaks",
    "description": "A curse afflicts those who hoard without releasing! Learn proper cleanup patterns.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 70,
    "map_file": "maps/L23_observatory.json",
    "challenges": [],
    "lesson": {
      "title": "Avoiding Memory Leaks",
      "content": [
        "A memory leak occurs when allocated memory is never freed - it stays 'lost' forever.",
        "In loops: allocate and free within each iteration, OR allocate once before the loop.",
        "In conditionals: ensure ALL branches free memory before returning."
      ],
      "examples": [
        {
          "code": "int loopNoLeak(int n) {\n    int sum = 0;\n    for(int i = 0; i < n; i++) {\n        int *p = malloc(sizeof(int));\n        *p = i;\n        sum += *p;\n        free(p);  // Free each iteration!\n    }\n    return sum;\n}",
          "explanation": "Each allocation is freed within its iteration - no leaks."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L23_Q1"},
        {"x": 416, "y": 224, "quest_id": "L23_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L23_Q1",
        "order": 1,
        "title": "Loop Cleanup",
        "description": "Sum values 0 to n-1 using malloc in a loop. Free properly each iteration!",
        "recommended": true,
        "function_signature": {
          "name": "loopSum",
          "return_type": "int",
          "parameters": [
            {"name": "n", "type": "int"}
          ]
        },
        "user_template": "int loopSum(int n) {\n    int sum = 0;\n    for(int i = 0; i < n; i++) {\n        // Allocate, add i to sum, free\n        \n    }\n    return sum;\n}",
        "test_cases": [
          {"input": [5], "expected": "10", "sample": true},
          {"input": [3], "expected": "3", "sample": true},
          {"input": [1], "expected": "0", "sample": false},
          {"input": [10], "expected": "45", "sample": false}
        ],
        "hints": [
          "int *p = malloc(sizeof(int)); *p = i;",
          "sum += *p; then free(p);",
          "Free inside the loop, not after!"
        ],
        "xp_reward": 30
      },
      {
        "id": "L23_Q2",
        "order": 2,
        "title": "Branch Cleanup",
        "description": "Allocate memory, return different values based on condition, but always free!",
        "recommended": false,
        "function_signature": {
          "name": "branchClean",
          "return_type": "int",
          "parameters": [
            {"name": "val", "type": "int"},
            {"name": "flag", "type": "int"}
          ]
        },
        "user_template": "int branchClean(int val, int flag) {\n    int *p = (int*)malloc(sizeof(int));\n    *p = val;\n    // If flag != 0, return *p doubled\n    // Otherwise return *p as-is\n    // IMPORTANT: Free memory on ALL paths!\n    \n}",
        "test_cases": [
          {"input": [5, 1], "expected": "10", "sample": true},
          {"input": [5, 0], "expected": "5", "sample": true},
          {"input": [10, 1], "expected": "20", "sample": false},
          {"input": [10, 0], "expected": "10", "sample": false}
        ],
        "hints": [
          "Save result before freeing: int result = ...;",
          "free(p); must happen before EVERY return",
          "Or: compute result first, free, then return"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L24",
    "title": "The Expanding Army",
    "theme": "L24_portal",
    "concept": "dynamic arrays",
    "description": "Your army grows! Use realloc to expand arrays when needed.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 75,
    "map_file": "maps/L24_portal.json",
    "challenges": [],
    "lesson": {
      "title": "Growing Arrays with Realloc",
      "content": [
        "realloc resizes allocated memory: ptr = realloc(ptr, new_size);",
        "It preserves existing data and may move the block to a new location.",
        "Always assign realloc's result back to the pointer (it may return a new address)."
      ],
      "examples": [
        {
          "code": "int growAndSum(int a, int b) {\n    int *arr = malloc(sizeof(int));\n    arr[0] = a;\n    arr = realloc(arr, 2 * sizeof(int));\n    arr[1] = b;\n    int sum = arr[0] + arr[1];\n    free(arr);\n    return sum;\n}",
          "explanation": "Start with 1 element, grow to 2, compute sum, free."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 224, "y": 224, "quest_id": "L24_Q1"},
        {"x": 416, "y": 224, "quest_id": "L24_Q2"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L24_Q1",
        "order": 1,
        "title": "Grow and Sum",
        "description": "Malloc for 1 int, store a, realloc to 2 ints, store b, return sum.",
        "recommended": true,
        "function_signature": {
          "name": "growSum",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
          ]
        },
        "user_template": "int growSum(int a, int b) {\n    // 1. Malloc space for 1 int, store a\n    // 2. Realloc to 2 ints, store b in [1]\n    // 3. Sum arr[0] + arr[1]\n    // 4. Free and return sum\n    \n}",
        "test_cases": [
          {"input": [10, 20], "expected": "30", "sample": true},
          {"input": [5, 5], "expected": "10", "sample": true},
          {"input": [0, 0], "expected": "0", "sample": false},
          {"input": [100, -50], "expected": "50", "sample": false}
        ],
        "hints": [
          "int *arr = malloc(sizeof(int)); arr[0] = a;",
          "arr = realloc(arr, 2 * sizeof(int)); arr[1] = b;",
          "Don't forget to free(arr) before returning!"
        ],
        "xp_reward": 35
      },
      {
        "id": "L24_Q2",
        "order": 2,
        "title": "Triple Grow",
        "description": "Start with malloc(1), realloc twice to reach size 3, store a,b,c, return sum.",
        "recommended": false,
        "function_signature": {
          "name": "tripleGrow",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"},
            {"name": "c", "type": "int"}
          ]
        },
        "user_template": "int tripleGrow(int a, int b, int c) {\n    // Malloc(1), store a\n    // Realloc(2), store b\n    // Realloc(3), store c\n    // Sum all three, free, return\n    \n}",
        "test_cases": [
          {"input": [1, 2, 3], "expected": "6", "sample": true},
          {"input": [10, 20, 30], "expected": "60", "sample": true},
          {"input": [0, 0, 0], "expected": "0", "sample": false},
          {"input": [100, 200, 300], "expected": "600", "sample": false}
        ],
        "hints": [
          "Each realloc grows by one element",
          "arr = realloc(arr, 2*sizeof(int)); then arr = realloc(arr, 3*sizeof(int));",
          "Sum: arr[0] + arr[1] + arr[2]"
        ],
        "xp_reward": 40
      }
    ]
  },
  {
    "id": "L25",
    "title": "Chain of Portals",
    "theme": "L25_sanctum",
    "concept": "linked lists",
    "description": "Create chains of nodes that point to each other - the foundation of linked lists!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int value;\n    struct Node *next;\n};\n\n// Write your function here\n\nint main() {\n    return 0;\n}",
    "hints": [],
    "xp_reward": 0,
    "total_xp_reward": 110,
    "map_file": "maps/L25_sanctum.json",
    "challenges": [],
    "lesson": {
      "title": "Linked Lists",
      "content": [
        "A linked list is a chain of nodes, each containing data and a pointer to the next node.",
        "struct Node { int value; struct Node *next; }; defines a self-referential struct.",
        "Traverse by following next pointers until you hit NULL (end of list)."
      ],
      "examples": [
        {
          "code": "int countNodes(struct Node *head) {\n    int count = 0;\n    struct Node *curr = head;\n    while(curr != NULL) {\n        count++;\n        curr = curr->next;\n    }\n    return count;\n}",
          "explanation": "Traverse from head to end, counting nodes."
        }
      ]
    },
    "world_config": {
      "width": 20,
      "height": 15,
      "spawn_x": 64,
      "spawn_y": 224,
      "terminals": [
        {"x": 160, "y": 224, "quest_id": "L25_Q1"},
        {"x": 288, "y": 224, "quest_id": "L25_Q2"},
        {"x": 416, "y": 224, "quest_id": "L25_Q3"}
      ],
      "preset": "tutorial"
    },
    "quests": [
      {
        "id": "L25_Q1",
        "order": 1,
        "title": "Create a Node",
        "description": "Allocate a Node, set its value, set next to NULL, return the value.",
        "recommended": true,
        "function_signature": {
          "name": "createNode",
          "return_type": "int",
          "parameters": [
            {"name": "val", "type": "int"}
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint createNode(int val) {\n    // Allocate a Node, set value=val, next=NULL\n    // Return the stored value, then free\n    \n}",
        "test_cases": [
          {"input": [42], "expected": "42", "sample": true},
          {"input": [100], "expected": "100", "sample": true},
          {"input": [0], "expected": "0", "sample": false},
          {"input": [-5], "expected": "-5", "sample": false}
        ],
        "hints": [
          "struct Node *n = malloc(sizeof(struct Node));",
          "n->value = val; n->next = NULL;",
          "int result = n->value; free(n); return result;"
        ],
        "xp_reward": 30
      },
      {
        "id": "L25_Q2",
        "order": 2,
        "title": "Count Nodes",
        "description": "Given a head pointer to a 3-node list, count and return the number of nodes.",
        "recommended": false,
        "function_signature": {
          "name": "countList",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"},
            {"name": "c", "type": "int"}
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint countList(int a, int b, int c) {\n    // Create 3 nodes: a -> b -> c -> NULL\n    // Count nodes by traversing, free all, return count\n    \n}",
        "test_cases": [
          {"input": [1, 2, 3], "expected": "3", "sample": true},
          {"input": [10, 20, 30], "expected": "3", "sample": true},
          {"input": [0, 0, 0], "expected": "3", "sample": false}
        ],
        "hints": [
          "Create 3 nodes and link them: n1->next = n2; n2->next = n3; n3->next = NULL;",
          "Traverse: while(curr != NULL) { count++; curr = curr->next; }",
          "Free all 3 nodes before returning"
        ],
        "xp_reward": 35
      },
      {
        "id": "L25_Q3",
        "order": 3,
        "title": "Last Value",
        "description": "Create a 3-node list (a->b->c), traverse to find the last value, return it.",
        "recommended": false,
        "function_signature": {
          "name": "lastValue",
          "return_type": "int",
          "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"},
            {"name": "c", "type": "int"}
          ]
        },
        "user_template": "struct Node {\n    int value;\n    struct Node *next;\n};\n\nint lastValue(int a, int b, int c) {\n    // Create list: a -> b -> c -> NULL\n    // Traverse to find last node (where next == NULL)\n    // Return its value, free all nodes\n    \n}",
        "test_cases": [
          {"input": [1, 2, 3], "expected": "3", "sample": true},
          {"input": [10, 20, 30], "expected": "30", "sample": true},
          {"input": [100, 200, 300], "expected": "300", "sample": false},
          {"input": [5, 5, 5], "expected": "5", "sample": false}
        ],
        "hints": [
          "Traverse: while(curr->next != NULL) curr = curr->next;",
          "When curr->next is NULL, curr is the last node",
          "Return curr->value after saving it, then free all nodes"
        ],
        "xp_reward": 45
      }
    ]
  }
]
