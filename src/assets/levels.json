[
  {
    "id": "L01",
    "title": "The First Spell",
    "concept": "printf",
    "description": "The door is voice-activated. Master the art of returning values to unlock it.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    printf(\"%d\\n\", getSecret());\n    return 0;\n}",
    "hints": [
      "Functions return values with the 'return' keyword",
      "The return type goes before the function name",
      "Example: int myFunc() { return 5; }"
    ],
    "xp_reward": 50,
    "map_file": "maps/L01_first_spell.json",
    "challenges": [],
    "lesson": {
      "title": "Functions and Return Values",
      "content": [
        "In C, functions can return values to their caller. This is one of the most fundamental concepts in programming.",
        "A function's return type tells the compiler what kind of value it will send back. The 'int' type means the function returns a whole number.",
        "Use the 'return' keyword followed by the value you want to send back."
      ],
      "examples": [
        {
          "code": "int getFive() {\n    return 5;\n}",
          "explanation": "This function returns the integer 5 whenever it's called."
        },
        {
          "code": "int getAnswer() {\n    return 42;\n}",
          "explanation": "Functions can return any integer value."
        }
      ]
    },
    "function_signature": {
      "name": "getSecret",
      "return_type": "int",
      "parameters": []
    },
    "user_template": "int getSecret() {\n    // Return the secret number: 42\n    \n}",
    "test_cases": [
      {"input": [], "expected": "42", "sample": true}
    ]
  },
  {
    "id": "L02",
    "title": "The Empty Backpack",
    "concept": "variables",
    "description": "The merchant needs to calculate the total weight of items. Help him add them together!",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    printf(\"%d\\n\", addWeight(10, 25));\n    return 0;\n}",
    "hints": [
      "Use the + operator to add numbers",
      "Return the sum of both parameters",
      "Example: return a + b;"
    ],
    "xp_reward": 75,
    "map_file": "maps/L02_empty_backpack.json",
    "challenges": [],
    "lesson": {
      "title": "Variables and Arithmetic",
      "content": [
        "Variables store data that your program can use and modify. In C, you must declare a variable's type before using it.",
        "Function parameters are special variables that receive values when the function is called.",
        "Arithmetic operators like + (add), - (subtract), * (multiply), and / (divide) work with numeric variables."
      ],
      "examples": [
        {
          "code": "int add(int x, int y) {\n    return x + y;\n}",
          "explanation": "Parameters x and y receive values from the caller, and we return their sum."
        },
        {
          "code": "int double(int n) {\n    return n * 2;\n}",
          "explanation": "We can perform arithmetic on parameters and return the result."
        }
      ]
    },
    "function_signature": {
      "name": "addWeight",
      "return_type": "int",
      "parameters": [
        {"name": "item1", "type": "int"},
        {"name": "item2", "type": "int"}
      ]
    },
    "user_template": "int addWeight(int item1, int item2) {\n    // Return the sum of item1 and item2\n    \n}",
    "test_cases": [
      {"input": [10, 25], "expected": "35", "sample": true},
      {"input": [5, 5], "expected": "10", "sample": true},
      {"input": [100, 200], "expected": "300", "sample": false},
      {"input": [0, 42], "expected": "42", "sample": false},
      {"input": [999, 1], "expected": "1000", "sample": false}
    ]
  },
  {
    "id": "L03",
    "title": "The Gatekeeper",
    "concept": "if/else",
    "description": "The guard blocks the path. He only respects warriors who can identify the larger of two numbers.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    printf(\"%d\\n\", maxValue(3, 7));\n    return 0;\n}",
    "hints": [
      "Use if/else to compare the two values",
      "if (a > b) means 'if a is greater than b'",
      "Return the larger value in each branch"
    ],
    "xp_reward": 100,
    "map_file": "maps/L03_gatekeeper.json",
    "challenges": [],
    "lesson": {
      "title": "Conditional Logic with if/else",
      "content": [
        "Programs often need to make decisions. The if/else statement lets your code choose between different paths based on conditions.",
        "A condition is an expression that evaluates to true or false. Comparison operators include: > (greater), < (less), >= (greater or equal), <= (less or equal), == (equal), != (not equal).",
        "The if block runs when the condition is true; the else block runs when it's false."
      ],
      "examples": [
        {
          "code": "int isPositive(int n) {\n    if (n > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
          "explanation": "Returns 1 if n is positive, 0 otherwise."
        },
        {
          "code": "int bigger(int a, int b) {\n    if (a > b) {\n        return a;\n    }\n    return b;\n}",
          "explanation": "Returns a if it's bigger, otherwise returns b."
        }
      ]
    },
    "function_signature": {
      "name": "maxValue",
      "return_type": "int",
      "parameters": [
        {"name": "a", "type": "int"},
        {"name": "b", "type": "int"}
      ]
    },
    "user_template": "int maxValue(int a, int b) {\n    // Return the larger of a and b\n    \n}",
    "test_cases": [
      {"input": [3, 7], "expected": "7", "sample": true},
      {"input": [10, 2], "expected": "10", "sample": true},
      {"input": [5, 5], "expected": "5", "sample": false},
      {"input": [-3, -7], "expected": "-3", "sample": false},
      {"input": [0, 100], "expected": "100", "sample": false},
      {"input": [42, 0], "expected": "42", "sample": false}
    ]
  },
  {
    "id": "L04",
    "title": "The Repeating Strike",
    "concept": "loops",
    "description": "The training dummy requires repeated strikes. Calculate the sum of all strike damage from 1 to n.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    printf(\"%d\\n\", sumStrikes(5));\n    return 0;\n}",
    "hints": [
      "Use a for loop: for(int i = 1; i <= n; i++)",
      "Create a variable to accumulate the sum",
      "Add each number to the sum inside the loop"
    ],
    "xp_reward": 125,
    "map_file": "maps/L04_repeating_strike.json",
    "challenges": [],
    "lesson": {
      "title": "Loops for Repetition",
      "content": [
        "Loops let you repeat code multiple times. The for loop is perfect when you know how many times to repeat.",
        "A for loop has three parts: initialization (int i = 1), condition (i <= n), and update (i++).",
        "The loop body executes repeatedly while the condition is true. Use a variable to accumulate results across iterations."
      ],
      "examples": [
        {
          "code": "int countTo(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum = sum + i;\n    }\n    return sum;\n}",
          "explanation": "This loop adds 1+2+3+...+n by accumulating each value."
        },
        {
          "code": "int multiply(int base, int times) {\n    int result = 0;\n    for (int i = 0; i < times; i++) {\n        result = result + base;\n    }\n    return result;\n}",
          "explanation": "Multiplication through repeated addition."
        }
      ]
    },
    "function_signature": {
      "name": "sumStrikes",
      "return_type": "int",
      "parameters": [
        {"name": "n", "type": "int"}
      ]
    },
    "user_template": "int sumStrikes(int n) {\n    // Return the sum of 1 + 2 + 3 + ... + n\n    \n}",
    "test_cases": [
      {"input": [5], "expected": "15", "sample": true},
      {"input": [10], "expected": "55", "sample": true},
      {"input": [1], "expected": "1", "sample": false},
      {"input": [100], "expected": "5050", "sample": false},
      {"input": [3], "expected": "6", "sample": false}
    ]
  },
  {
    "id": "L05",
    "title": "Array Fortress",
    "concept": "arrays",
    "description": "A fortress of many rooms. Return the value stored at a specific room index.",
    "code_template": "#include <stdio.h>\n\n// Write your function here\n\nint main() {\n    printf(\"%d\\n\", getRoom(2));\n    return 0;\n}",
    "hints": [
      "Arrays store multiple values at numbered positions",
      "Array indices start at 0, not 1",
      "Use arrayName[index] to access a value"
    ],
    "xp_reward": 200,
    "map_file": "maps/L05_array_fortress.json",
    "challenges": [],
    "lesson": {
      "title": "Arrays: Collections of Data",
      "content": [
        "Arrays let you store multiple values of the same type in a single variable. Each value has an index (position number).",
        "IMPORTANT: Array indices start at 0! The first element is at index 0, the second at index 1, and so on.",
        "Access array elements with square brackets: arr[0] gets the first element, arr[2] gets the third."
      ],
      "examples": [
        {
          "code": "int getFirst() {\n    int rooms[3] = {10, 20, 30};\n    return rooms[0];\n}",
          "explanation": "Returns 10 - the element at index 0 (first position)."
        },
        {
          "code": "int getThird() {\n    int data[5] = {5, 10, 15, 20, 25};\n    return data[2];\n}",
          "explanation": "Returns 15 - the element at index 2 (third position)."
        }
      ]
    },
    "function_signature": {
      "name": "getRoom",
      "return_type": "int",
      "parameters": [
        {"name": "index", "type": "int"}
      ]
    },
    "user_template": "int getRoom(int index) {\n    // Create array: {10, 20, 30, 40, 50}\n    // Return the element at 'index'\n    \n}",
    "test_cases": [
      {"input": [0], "expected": "10", "sample": true},
      {"input": [2], "expected": "30", "sample": true},
      {"input": [4], "expected": "50", "sample": false},
      {"input": [1], "expected": "20", "sample": false},
      {"input": [3], "expected": "40", "sample": false}
    ]
  },
  {
    "id": "L06",
    "title": "The Spell Scroll",
    "concept": "void functions",
    "description": "The ancient scroll contains a spell, but it must be spoken to activate. Create a function that speaks the incantation.",
    "code_template": "#include <stdio.h>\n\n// Define a void function called 'cast_spell' that prints \"Abracadabra!\"\n\nint main() {\n    cast_spell();\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Abracadabra!\n"
    },
    "hints": [
      "Void functions are defined as: void functionName() { ... }",
      "Use printf inside the function to print the spell",
      "Don't forget the newline \\n"
    ],
    "xp_reward": 150,
    "map_file": "maps/L06_spell_scroll.json",
    "challenges": [
      {
        "id": "cast_spell_void",
        "prompt": "Define and call a void function 'cast_spell' that prints the incantation.",
        "expected_output": "Abracadabra!",
        "starter_code": "#include <stdio.h>\n\n// Define a void function called 'cast_spell' that prints \"Abracadabra!\"\n\nint main() {\n    cast_spell();\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L07",
    "title": "The Damage Calculator",
    "concept": "return values",
    "description": "The enchanting table can calculate weapon damage, but only if you create a formula that returns the result.",
    "code_template": "#include <stdio.h>\n\n// Define a function 'calculate_damage' that takes (int base, int multiplier)\n// and returns base * multiplier\n\nint main() {\n    int damage = calculate_damage(10, 3);\n    printf(\"Damage: %d\\n\", damage);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Damage: 30\n"
    },
    "hints": [
      "Return type goes before function name: int functionName(...)",
      "Use the return keyword to send back a value",
      "return base * multiplier;"
    ],
    "xp_reward": 175,
    "map_file": "maps/L07_damage_calc.json",
    "challenges": [
      {
        "id": "calc_damage_return",
        "prompt": "Implement 'calculate_damage' so the table reports the correct damage.",
        "expected_output": "Damage: 30",
        "starter_code": "#include <stdio.h>\n\n// Define a function 'calculate_damage' that takes (int base, int multiplier)\n// and returns base * multiplier\n\nint main() {\n    int damage = calculate_damage(10, 3);\n    printf(\"Damage: %d\\n\", damage);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L08",
    "title": "The Stack Spire",
    "concept": "stack frames",
    "description": "Each floor of the spire is a function call. Climb up through nested calls, then return back down.",
    "code_template": "#include <stdio.h>\n\nvoid floor_3() {\n    printf(\"Floor 3 - Top!\\n\");\n}\n\nvoid floor_2() {\n    printf(\"Floor 2\\n\");\n    // Call floor_3 here\n}\n\nvoid floor_1() {\n    printf(\"Floor 1\\n\");\n    floor_2();\n}\n\nint main() {\n    printf(\"Ground Floor\\n\");\n    floor_1();\n    printf(\"Back to Ground\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Ground Floor\nFloor 1\nFloor 2\nFloor 3 - Top!\nBack to Ground\n"
    },
    "hints": [
      "Call floor_3() from inside floor_2().",
      "Execution climbs up the call stack and then unwinds.",
      "Match the exact output order, including newlines."
    ],
    "xp_reward": 200,
    "map_file": "maps/L08_stack_spire.json",
    "challenges": [
      {
        "id": "stack_spire_calls",
        "prompt": "Complete the call chain so the hero climbs to Floor 3 and back.",
        "expected_output": "Ground Floor\nFloor 1\nFloor 2\nFloor 3 - Top!\nBack to Ground",
        "starter_code": "#include <stdio.h>\n\nvoid floor_3() {\n    printf(\"Floor 3 - Top!\\n\");\n}\n\nvoid floor_2() {\n    printf(\"Floor 2\\n\");\n    // Call floor_3 here\n}\n\nvoid floor_1() {\n    printf(\"Floor 1\\n\");\n    floor_2();\n}\n\nint main() {\n    printf(\"Ground Floor\\n\");\n    floor_1();\n    printf(\"Back to Ground\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L09",
    "title": "The Global Artifact",
    "concept": "scope",
    "description": "The temple's central artifact is visible from all chambers. But each room has its own treasures only accessible within.",
    "code_template": "#include <stdio.h>\n\n// Declare a global variable 'artifact_power' = 100\n\nvoid east_chamber() {\n    int local_gem = 10;\n    printf(\"East: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nvoid west_chamber() {\n    int local_gem = 20;\n    printf(\"West: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nint main() {\n    east_chamber();\n    west_chamber();\n    printf(\"Center: artifact=%d\\n\", artifact_power);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "East: artifact=100, gem=10\nWest: artifact=100, gem=20\nCenter: artifact=100\n"
    },
    "hints": [
      "Declare 'artifact_power' outside of any function.",
      "Global variables can be used in any function in the file.",
      "Keep each chamber's local_gem variable inside its own function."
    ],
    "xp_reward": 200,
    "map_file": "maps/L09_global_artifact.json",
    "challenges": [
      {
        "id": "global_vs_local_scope",
        "prompt": "Make the artifact power visible in all chambers while keeping gems local.",
        "expected_output": "East: artifact=100, gem=10\nWest: artifact=100, gem=20\nCenter: artifact=100",
        "starter_code": "#include <stdio.h>\n\n// Declare a global variable 'artifact_power' = 100\n\nvoid east_chamber() {\n    int local_gem = 10;\n    printf(\"East: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nvoid west_chamber() {\n    int local_gem = 20;\n    printf(\"West: artifact=%d, gem=%d\\n\", artifact_power, local_gem);\n}\n\nint main() {\n    east_chamber();\n    west_chamber();\n    printf(\"Center: artifact=%d\\n\", artifact_power);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L10",
    "title": "The Recursive Mirror",
    "concept": "recursion",
    "description": "The mirror shows infinite reflections... but there must be a stopping point, or you'll be trapped forever!",
    "code_template": "#include <stdio.h>\n\nvoid reflect(int depth) {\n    if (depth <= 0) {\n        printf(\"Base reflection reached!\\n\");\n        return;\n    }\n    printf(\"Reflection depth: %d\\n\", depth);\n    // Call reflect with depth - 1\n}\n\nint main() {\n    reflect(3);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Reflection depth: 3\nReflection depth: 2\nReflection depth: 1\nBase reflection reached!\n"
    },
    "hints": [
      "Always include a base case to stop recursion.",
      "Call reflect(depth - 1) to move toward the base case.",
      "Make sure you print at each depth before the recursive call."
    ],
    "xp_reward": 250,
    "map_file": "maps/L10_recursive_mirror.json",
    "challenges": [
      {
        "id": "recursive_reflection",
        "prompt": "Complete the recursive call so the reflections count down to the base case.",
        "expected_output": "Reflection depth: 3\nReflection depth: 2\nReflection depth: 1\nBase reflection reached!",
        "starter_code": "#include <stdio.h>\n\nvoid reflect(int depth) {\n    if (depth <= 0) {\n        printf(\"Base reflection reached!\\n\");\n        return;\n    }\n    printf(\"Reflection depth: %d\\n\", depth);\n    // Call reflect with depth - 1\n}\n\nint main() {\n    reflect(3);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L11",
    "title": "The Address Spell",
    "concept": "address-of operator",
    "description": "To locate the hidden treasure, you must discover its exact address in the memory realm.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    // Print the ADDRESS of treasure using &\n    // Format: printf(\"%p\\n\", ...);\n    return 0;\n}",
    "success_criteria": {
      "type": "compile_only"
    },
    "hints": [
      "Use the & operator to get the address of a variable.",
      "Print addresses with %p and cast to (void*).",
      "The exact address changes each run; we only require compilation."
    ],
    "xp_reward": 225,
    "map_file": "maps/L11_address_spell.json",
    "challenges": [
      {
        "id": "print_address",
        "prompt": "Reveal the memory address of the treasure using the address-of operator.",
        "expected_output": "(varies)",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    // Print the ADDRESS of treasure using & and %p\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L12",
    "title": "The Grappling Hook",
    "concept": "pointer declaration",
    "description": "Your grappling hook can grab distant ledges, but first you must aim it. Declare where it points!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int ledge = 100;\n    // Declare a pointer 'hook' and point it to ledge\n    // Then print the value hook points to\n    printf(\"Grabbed: %d\\n\", *hook);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Grabbed: 100\n"
    },
    "hints": [
      "Declare a pointer with: int *name = &variable;",
      "The * in the declaration means 'pointer to int'.",
      "Use &ledge to get the address of ledge."
    ],
    "xp_reward": 250,
    "map_file": "maps/L12_grappling_hook.json",
    "challenges": [
      {
        "id": "pointer_declare_hook",
        "prompt": "Declare the 'hook' pointer so it grabs the ledge's value.",
        "expected_output": "Grabbed: 100",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int ledge = 100;\n    // Declare a pointer 'hook' and point it to ledge\n    // Then print the value hook points to\n    printf(\"Grabbed: %d\\n\", *hook);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L13",
    "title": "The Dereference Pull",
    "concept": "dereference operator",
    "description": "The treasure is behind a barrier. Use your pointer to pull its value to you!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int hidden_treasure = 777;\n    int *ptr = &hidden_treasure;\n    \n    // Change the treasure's value to 999 using the pointer\n    // Then print it\n    printf(\"Treasure value: %d\\n\", hidden_treasure);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Treasure value: 999\n"
    },
    "hints": [
      "Use *ptr on the left side of = to change the value.",
      "ptr stores an address; *ptr reads or writes the value at that address.",
      "After updating through the pointer, printing hidden_treasure shows the new value."
    ],
    "xp_reward": 275,
    "map_file": "maps/L13_dereference_pull.json",
    "challenges": [
      {
        "id": "dereference_update",
        "prompt": "Use the pointer to change the treasure's value to 999.",
        "expected_output": "Treasure value: 999",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int hidden_treasure = 777;\n    int *ptr = &hidden_treasure;\n    \n    // Change the treasure's value to 999 using the pointer\n    // Then print it\n    printf(\"Treasure value: %d\\n\", hidden_treasure);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L14",
    "title": "The Array Navigator",
    "concept": "pointer arithmetic",
    "description": "The corridor has numbered chambers. Navigate to chamber 3 using pointer arithmetic.",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int chambers[5] = {10, 20, 30, 40, 50};\n    int *ptr = chambers;  // Points to first element\n    \n    // Use pointer arithmetic to print the 4th chamber (index 3)\n    // Hint: *(ptr + 3) or ptr[3]\n    printf(\"Chamber 3 contains: %d\\n\", ???);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Chamber 3 contains: 40\n"
    },
    "hints": [
      "Adding 1 to a pointer moves it to the next array element.",
      "ptr[3] is the same as *(ptr + 3).",
      "Index 3 is the 4th chamber in the corridor."
    ],
    "xp_reward": 300,
    "map_file": "maps/L14_array_navigator.json",
    "challenges": [
      {
        "id": "pointer_arithmetic_navigate",
        "prompt": "Use pointer arithmetic to read the value in chamber 3 (index 3).",
        "expected_output": "Chamber 3 contains: 40",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int chambers[5] = {10, 20, 30, 40, 50};\n    int *ptr = chambers;  // Points to first element\n    \n    // Use pointer arithmetic to print the 4th chamber (index 3)\n    // Hint: *(ptr + 3) or ptr[3]\n    printf(\"Chamber 3 contains: %d\\n\", ???);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L15",
    "title": "The Null Trap",
    "concept": "null pointers",
    "description": "Some paths lead to void. Check before you step, or face a SEGFAULT!",
    "code_template": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    int *safe_ptr = &treasure;\n    int *trap_ptr = NULL;\n    \n    // Safely print values - check for NULL first!\n    // If pointer is NULL, print \"Path is blocked!\"\n    // If pointer is valid, print \"Found: X\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Found: 42\nPath is blocked!\n"
    },
    "hints": [
      "Compare pointers to NULL before dereferencing.",
      "Print one line for the safe path and one for the trap.",
      "Use if/else to choose which message to print."
    ],
    "xp_reward": 350,
    "map_file": "maps/L15_null_trap.json",
    "challenges": [
      {
        "id": "null_pointer_check",
        "prompt": "Check each pointer before using it so you avoid the null trap.",
        "expected_output": "Found: 42\nPath is blocked!",
        "starter_code": "#include <stdio.h>\n\nint main() {\n    int treasure = 42;\n    int *safe_ptr = &treasure;\n    int *trap_ptr = NULL;\n    \n    // Safely print values - check for NULL first!\n    // If pointer is NULL, print \"Path is blocked!\"\n    // If pointer is valid, print \"Found: X\"\n    \n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L16",
    "title": "The Blueprint Scroll",
    "concept": "struct definition",
    "description": "The ancient scroll contains a blueprint for creating heroes. Define the structure that holds a warrior's attributes.",
    "code_template": "#include <stdio.h>\n\n// Define a struct 'Hero' with:\n// - char name[50]\n// - int hp\n// - int level\n\nint main() {\n    struct Hero warrior = {\"Valor\", 100, 5};\n    printf(\"Hero: %s, HP: %d, Level: %d\\n\", warrior.name, warrior.hp, warrior.level);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Hero: Valor, HP: 100, Level: 5\n"
    },
    "hints": [
      "Structs group related data together using: struct Name { ... };",
      "Use 'char name[50]' for a string field",
      "Initialize with: struct Hero h = {\"name\", 100, 5};"
    ],
    "xp_reward": 300,
    "map_file": "maps/L16_blueprint_scroll.json",
    "challenges": [
      {
        "id": "define_hero_struct",
        "prompt": "Define the Hero struct with name, hp, and level fields.",
        "expected_output": "Hero: Valor, HP: 100, Level: 5",
        "starter_code": "#include <stdio.h>\n\n// Define a struct 'Hero' with name, hp, and level\n\nint main() {\n    struct Hero warrior = {\"Valor\", 100, 5};\n    printf(\"Hero: %s, HP: %d, Level: %d\\n\", warrior.name, warrior.hp, warrior.level);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L17",
    "title": "The Chest Contents",
    "concept": "struct members",
    "description": "You found a treasure chest! Use dot notation to access and modify its contents.",
    "code_template": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint main() {\n    struct Chest treasure;\n    \n    // Set gold to 500, gems to 10, keys to 3\n    // Then print: \"Chest: X gold, Y gems, Z keys\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Chest: 500 gold, 10 gems, 3 keys\n"
    },
    "hints": [
      "Access struct members with dot notation: chest.gold = 500;",
      "Each field must be set individually",
      "Use %d for integers in printf"
    ],
    "xp_reward": 325,
    "map_file": "maps/L17_chest_contents.json",
    "challenges": [
      {
        "id": "access_struct_members",
        "prompt": "Set the chest contents using dot notation and print the result.",
        "expected_output": "Chest: 500 gold, 10 gems, 3 keys",
        "starter_code": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n    int gems;\n    int keys;\n};\n\nint main() {\n    struct Chest treasure;\n    // Set gold=500, gems=10, keys=3 using dot notation\n    // Print: \"Chest: X gold, Y gems, Z keys\"\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L18",
    "title": "The Teleport Chest",
    "concept": "struct pointers",
    "description": "The chest is behind a magical barrier. Use a pointer to reach through and modify its contents!",
    "code_template": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n};\n\nvoid add_gold(struct Chest *c, int amount) {\n    // Use arrow operator to add gold\n}\n\nint main() {\n    struct Chest treasure = {100};\n    add_gold(&treasure, 50);\n    printf(\"Gold: %d\\n\", treasure.gold);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Gold: 150\n"
    },
    "hints": [
      "Use the arrow operator (->) to access members through a pointer",
      "c->gold is equivalent to (*c).gold",
      "Add the amount to the existing gold: c->gold += amount;"
    ],
    "xp_reward": 350,
    "map_file": "maps/L18_teleport_chest.json",
    "challenges": [
      {
        "id": "struct_pointer_arrow",
        "prompt": "Use the arrow operator to modify the chest through a pointer.",
        "expected_output": "Gold: 150",
        "starter_code": "#include <stdio.h>\n\nstruct Chest {\n    int gold;\n};\n\nvoid add_gold(struct Chest *c, int amount) {\n    // Use -> to add gold\n}\n\nint main() {\n    struct Chest treasure = {100};\n    add_gold(&treasure, 50);\n    printf(\"Gold: %d\\n\", treasure.gold);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L19",
    "title": "The Guild Hierarchy",
    "concept": "nested structs",
    "description": "The guild has a hierarchy. Each guild has a leader, and the leader is also a hero with their own attributes.",
    "code_template": "#include <stdio.h>\n\nstruct Hero {\n    char name[50];\n    int level;\n};\n\nstruct Guild {\n    char guild_name[50];\n    struct Hero leader;\n    int member_count;\n};\n\nint main() {\n    struct Guild warriors = {\"Iron Fist\", {\"Maximus\", 50}, 100};\n    \n    // Print: \"Guild: X, Leader: Y (Lv.Z), Members: N\"\n    printf(\"Guild: %s, Leader: %s (Lv.%d), Members: %d\\n\",\n           ???);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Guild: Iron Fist, Leader: Maximus (Lv.50), Members: 100\n"
    },
    "hints": [
      "Access nested struct members with multiple dots: guild.leader.name",
      "The leader is a Hero struct inside the Guild struct",
      "Use warriors.guild_name, warriors.leader.name, etc."
    ],
    "xp_reward": 375,
    "map_file": "maps/L19_guild_hierarchy.json",
    "challenges": [
      {
        "id": "nested_struct_access",
        "prompt": "Access the nested Hero struct inside Guild to print the hierarchy.",
        "expected_output": "Guild: Iron Fist, Leader: Maximus (Lv.50), Members: 100",
        "starter_code": "#include <stdio.h>\n\nstruct Hero {\n    char name[50];\n    int level;\n};\n\nstruct Guild {\n    char guild_name[50];\n    struct Hero leader;\n    int member_count;\n};\n\nint main() {\n    struct Guild warriors = {\"Iron Fist\", {\"Maximus\", 50}, 100};\n    // Print the guild info using nested access\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L20",
    "title": "The Army Roster",
    "concept": "array of structs",
    "description": "The army needs a roster! Create an array of soldiers and iterate through them.",
    "code_template": "#include <stdio.h>\n\nstruct Soldier {\n    char name[20];\n    int strength;\n};\n\nint main() {\n    struct Soldier army[3] = {\n        {\"Grunt\", 10},\n        {\"Knight\", 25},\n        {\"Champion\", 50}\n    };\n    \n    // Loop through and print each soldier\n    // Format: \"Soldier: X, Strength: Y\"\n    \n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Soldier: Grunt, Strength: 10\nSoldier: Knight, Strength: 25\nSoldier: Champion, Strength: 50\n"
    },
    "hints": [
      "Use a for loop: for(int i = 0; i < 3; i++)",
      "Access array elements with: army[i].name",
      "Each iteration prints one soldier"
    ],
    "xp_reward": 400,
    "map_file": "maps/L20_army_roster.json",
    "challenges": [
      {
        "id": "array_of_structs_loop",
        "prompt": "Loop through the army array and print each soldier.",
        "expected_output": "Soldier: Grunt, Strength: 10\nSoldier: Knight, Strength: 25\nSoldier: Champion, Strength: 50",
        "starter_code": "#include <stdio.h>\n\nstruct Soldier {\n    char name[20];\n    int strength;\n};\n\nint main() {\n    struct Soldier army[3] = {\n        {\"Grunt\", 10},\n        {\"Knight\", 25},\n        {\"Champion\", 50}\n    };\n    // Loop and print each soldier\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L21",
    "title": "Summon Land",
    "concept": "malloc basics",
    "description": "The void stretches before you. Use malloc to summon solid ground from nothingness!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate memory for one integer using malloc\n    int *land = ???;\n    \n    *land = 42;\n    printf(\"Land summoned with value: %d\\n\", *land);\n    \n    free(land);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Land summoned with value: 42\n"
    },
    "hints": [
      "malloc returns a pointer to allocated memory",
      "Use: int *ptr = (int*)malloc(sizeof(int));",
      "sizeof(int) tells malloc how many bytes to allocate"
    ],
    "xp_reward": 425,
    "map_file": "maps/L21_summon_land.json",
    "challenges": [
      {
        "id": "malloc_single_int",
        "prompt": "Use malloc to allocate space for one integer.",
        "expected_output": "Land summoned with value: 42",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate memory for one integer\n    int *land = ???;\n    *land = 42;\n    printf(\"Land summoned with value: %d\\n\", *land);\n    free(land);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L22",
    "title": "The Banish Spell",
    "concept": "free memory",
    "description": "What you summon, you must also banish! Release the memory back to the void.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *summoned = (int*)malloc(sizeof(int));\n    *summoned = 999;\n    printf(\"Value before banish: %d\\n\", *summoned);\n    \n    // Free the memory here\n    \n    printf(\"Memory banished!\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Value before banish: 999\nMemory banished!\n"
    },
    "hints": [
      "Use free(pointer) to release allocated memory",
      "Always free memory that was malloc'd",
      "After free, don't use the pointer again"
    ],
    "xp_reward": 450,
    "map_file": "maps/L22_banish_spell.json",
    "challenges": [
      {
        "id": "free_memory",
        "prompt": "Free the allocated memory using the free function.",
        "expected_output": "Value before banish: 999\nMemory banished!",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *summoned = (int*)malloc(sizeof(int));\n    *summoned = 999;\n    printf(\"Value before banish: %d\\n\", *summoned);\n    // Free the memory\n    printf(\"Memory banished!\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L23",
    "title": "The Cursed Hoarding",
    "concept": "memory leaks",
    "description": "A curse afflicts those who hoard without releasing! Find and fix the memory leak.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    for(int i = 0; i < 3; i++) {\n        int *treasure = (int*)malloc(sizeof(int));\n        *treasure = (i + 1) * 100;\n        printf(\"Found treasure: %d\\n\", *treasure);\n        // FIX: Free memory inside the loop!\n    }\n    printf(\"All treasures collected properly!\\n\");\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Found treasure: 100\nFound treasure: 200\nFound treasure: 300\nAll treasures collected properly!\n"
    },
    "hints": [
      "Memory allocated inside a loop should be freed inside the loop",
      "Each malloc needs a matching free",
      "Add free(treasure) before the loop iteration ends"
    ],
    "xp_reward": 475,
    "map_file": "maps/L23_cursed_hoarding.json",
    "challenges": [
      {
        "id": "fix_memory_leak",
        "prompt": "Add the missing free() call to prevent the memory leak.",
        "expected_output": "Found treasure: 100\nFound treasure: 200\nFound treasure: 300\nAll treasures collected properly!",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    for(int i = 0; i < 3; i++) {\n        int *treasure = (int*)malloc(sizeof(int));\n        *treasure = (i + 1) * 100;\n        printf(\"Found treasure: %d\\n\", *treasure);\n        // Add free here\n    }\n    printf(\"All treasures collected properly!\\n\");\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L24",
    "title": "The Expanding Army",
    "concept": "dynamic arrays",
    "description": "Your army grows! Use realloc to expand the barracks when new recruits arrive.",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *army = (int*)malloc(2 * sizeof(int));\n    army[0] = 10;\n    army[1] = 20;\n    printf(\"Army size 2: %d, %d\\n\", army[0], army[1]);\n    \n    // Expand to size 4 using realloc\n    army = ???;\n    army[2] = 30;\n    army[3] = 40;\n    printf(\"Army size 4: %d, %d, %d, %d\\n\", army[0], army[1], army[2], army[3]);\n    \n    free(army);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Army size 2: 10, 20\nArmy size 4: 10, 20, 30, 40\n"
    },
    "hints": [
      "realloc can grow or shrink allocated memory",
      "Use: ptr = (int*)realloc(ptr, new_size);",
      "realloc preserves existing data"
    ],
    "xp_reward": 500,
    "map_file": "maps/L24_expanding_army.json",
    "challenges": [
      {
        "id": "realloc_expand",
        "prompt": "Use realloc to expand the army array from 2 to 4 elements.",
        "expected_output": "Army size 2: 10, 20\nArmy size 4: 10, 20, 30, 40",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *army = (int*)malloc(2 * sizeof(int));\n    army[0] = 10;\n    army[1] = 20;\n    printf(\"Army size 2: %d, %d\\n\", army[0], army[1]);\n    // Expand to size 4\n    army[2] = 30;\n    army[3] = 40;\n    printf(\"Army size 4: %d, %d, %d, %d\\n\", army[0], army[1], army[2], army[3]);\n    free(army);\n    return 0;\n}"
      }
    ]
  },
  {
    "id": "L25",
    "title": "Chain of Portals",
    "concept": "linked lists",
    "description": "Create a chain of magical portals, each pointing to the next. This is the foundation of linked lists!",
    "code_template": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Portal {\n    int destination;\n    struct Portal *next;\n};\n\nint main() {\n    // Create 3 portals: 10 -> 20 -> 30 -> NULL\n    struct Portal *first = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *second = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *third = (struct Portal*)malloc(sizeof(struct Portal));\n    \n    first->destination = 10;\n    first->next = second;\n    \n    second->destination = 20;\n    // Link second to third\n    \n    third->destination = 30;\n    third->next = NULL;\n    \n    // Traverse and print\n    struct Portal *current = first;\n    while(current != NULL) {\n        printf(\"Portal to: %d\\n\", current->destination);\n        current = current->next;\n    }\n    \n    free(first); free(second); free(third);\n    return 0;\n}",
    "success_criteria": {
      "type": "exact_match",
      "expected_stdout": "Portal to: 10\nPortal to: 20\nPortal to: 30\n"
    },
    "hints": [
      "Link nodes with: node->next = another_node;",
      "The last node's next should be NULL",
      "Traverse with: while(current != NULL) { ... current = current->next; }"
    ],
    "xp_reward": 550,
    "map_file": "maps/L25_chain_portals.json",
    "challenges": [
      {
        "id": "linked_list_basic",
        "prompt": "Complete the portal chain by linking second to third.",
        "expected_output": "Portal to: 10\nPortal to: 20\nPortal to: 30",
        "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Portal {\n    int destination;\n    struct Portal *next;\n};\n\nint main() {\n    struct Portal *first = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *second = (struct Portal*)malloc(sizeof(struct Portal));\n    struct Portal *third = (struct Portal*)malloc(sizeof(struct Portal));\n    \n    first->destination = 10;\n    first->next = second;\n    \n    second->destination = 20;\n    // Link second to third\n    \n    third->destination = 30;\n    third->next = NULL;\n    \n    struct Portal *current = first;\n    while(current != NULL) {\n        printf(\"Portal to: %d\\n\", current->destination);\n        current = current->next;\n    }\n    \n    free(first); free(second); free(third);\n    return 0;\n}"
      }
    ]
  }
]
